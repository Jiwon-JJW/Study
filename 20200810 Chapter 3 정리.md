# CHAPTER 3




## 01. 연산자와 피연산자

#### 연산자란?

* 연산을 수행하는 기호
  Ex) '+' 기호의 경우, **덧셈 연산을 수행**하며 **'덧셈 연산자'**로 부름.
* 연산자는 피연산자로 연산을 수행하고 나면, 결과값을 반환.
  


#### 피연산자(operand) 란?

* 연산자가 연산을 수행하기 위한 연산의 대상.

  

#### 예제:


|        X |   +    | 3        |
| -------: | :----: | -------- |
| 피연산자 | 연산자 | 피연산자 |

> **연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현**한 것을 **'식(expression)'**이라고 한다
> 또한, **식을 계산하여 결과를 얻는 것**을 **'식을 평가(evaluation)한다'**라고 한다.



```java
int x = 5;

4 * x + 3
> 4 * 5 + 3
  > 23        // 23의 결과를 얻었지만, 이 값은 쓰이지 않고 사라짐.
```

* 위의 값을 지속하여 사용하고 싶다면, **대입 연산자 기능**을 사용해야함.

  ```java
  int x = 5;
  int y = 4 * x + 3;     //x의 값이 5일 경우, y의 값은 연산 이후 23으로 출력.
  System.out.println(y); //y의 값인 23이 화면에 출력 됨.
  ```

* 만일 평가 결과를 출력하기만 원한다면, println메서드의 괄호() 안에 직접 식을 쓰는것도 가능.

  ```java
  int x = 5;
  System.out.println(4 * x + 3);
  > System.out.println(23);
  ```

  

## 02. 연산자의 종류

| 종류        | 연산자                   | 설명                                         |
| ----------- | ------------------------ | -------------------------------------------- |
| 산술 연산자 | +, -, *, /, %, <<, >>    | 사칙 연산과 나머지 연산(%)                   |
| 비교 연산자 | <, >, <=, >=, ==, !=     | 크고 작음과 같고 다름을 비교                 |
| 논리 연산자 | &&, \|\|, !, &, \|, ^, ~ | '그리고(AND)'와 '또는(OR)'으로 조건을 연결   |
| 대입 연산자 | =                        | 우변의 값을 좌변에 저장                      |
| 기타        | (type) ?: instanceof     | 형변환 연산자, 삼항 연산자, instanceof연산자 |

> 피연산자의 개수로 연산자를 분류하기도 함.
>
> 1. 피연산자의 개수가 1개일 경우: 단항 연산자
> 2. 피연산자의 개수가 2개일 경우: 이항 연산자
> 3. 피연산자의 개수가 3개일 경우: 삼항 연산자
>
> **대부분의 연산자는 '이항 연산자'이다.**



* 둘 다 같은 '-' 기호를 사용하지만, 다른 연산자를 사용하는 식:

|           - | 3    |      -      | 5    |
| ----------: | ---- | :---------: | ---- |
| 부호 연산자 |      | 뺄셈 연산자 |      |



* -3 -5 일 경우
  -3 , 5는 뺄셈 연산자의 피연산자 이고,
  -3의 3은 부호 연산자의 피연산자이다.

  

  * 연산자를 기능별, 피연산자의 개수별로 나누어 분류하는 이유: 
    **연산자의 우선순위 때문에.**


    연산자마다 우선순위가 다르지만, **같은 종류의 연산자들은 우선순위가 비슷.**
    종류별로 우선순위를 외우면 기억하기 수월



## 03. 연산자의 우선순위

* 식에 사용된 연산자가 둘 이상인 경우, 연산자의 **우선순위**에 의해서 연산순서가 결정 됨.
  Ex) 곱셈과 나눗셈(*, /)은 덧셈과 뺄셈(+, -)보다 우선순위가 높음.

  | 식                  | 설명                                                         |
  | ------------------- | ------------------------------------------------------------ |
  | -x + 3              | 단항 연산자가 이항 연산자보다 우선순위가 높다. 그래서 x의 부호를 바꾼 다음 덧셈이 수행 됨.<br />여기서 '-'는 뺄셈 연산자가 아니라 부호 연산자이다. |
  | x + 3 * y           | 곱셈과 나눗셈이 덧셈과 뺄셈보다 우선순위가 높다.<br />그래서 '3 * y'가 먼저 계산 됨. |
  | x + 3 > y - 2       | 비교 연산자(>)보다 산술 연산자 '+'와 '-'가 먼저 수행된다.<br />그래서 'x + 3'과 'y - 2'가 먼저 계산된 다음에 '>'가 수행된다. |
  | x > 3 && x < 5      | 논리 연산자 '&&'보다 비교 연산자가 먼저 수행된다.<br />그래서 'x > 3'와 'x < 5'가 먼저 계산된 다음에 '&&'가. 수행된다.<br />식의 의미는 'x가 3보다 크고 5보다 작다'이다. |
  | result = x + y * 3; | 대입 연산자는 연산자 중에서 제일 우선순위가 낮다.<br />그래서 우변의 최종 연산결과가 변수 result에 저장된다. |

  

## 04. 연산자의 결합 규칙

* 하나의 식에 같은 우선순위의 연산자들이 여러개 있을 경우, 나름대로의 규칙을 가지고 처리를 하는 데,
  그 규칙을 "연산자의 결합규칙"이라고 한다.



* 연산자의 결합 규칙이 왼쪽에서 오른쪽인 경우: 3 + 4 - 5
  
* 연산자의 결합 규칙이 오른쪽에서 왼쪽인 경우: x = y = 3

  > 대입 연산자는 연산자의 결합 규칙이 오른쪽에서 왼쪽으로 진행 된다.
  > 따라서 오른쪽의 대입 연산자인 y = 3 부터 처리 하여, y에 3이 저장되고, 그 이후에 x=3이 수행된다.

  **대입연산자는 우변의 값을 좌변에 저장하고, 저장된 값을 연산결과로 반환한다.**



1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.



* 예제:

  ```java
  class Ex3_1 {
    public static void main(String[] args) {
      int x, y;
      
      x = y = 3; //y에 3이 저장된 후에, x에 3이 저장된다.
      System.out.println("x=" + x);
      System.out.println("y=" + y);
    }
  }
  ```

  > 이 코드의 결과:
  > x = 3
  > y = 3



## 05. 증감 연산자 ++과 --

**증감 연산자 (++) - 피연산자의 값을 1 증가시킨다.**

> 정수와 실수가 모두 **가능**, 상수는 값을 변경할 수 없기에 **불가능**.
> 연산 결과의 타입은 피연산자의 타입과 같다.

**감소 연산자(--) - 피연산자의 값을 1 감소시킨다.**



* 단항 연산자는 피연산자의 왼쪽에 위치하지만. 증가 연산자 '++'와 감소 연산자 '--'는 양쪽 모두 가능.
  이는 두 가지 이름으로 불린다.

  * 전위형(prefix) : 피연산자의 왼쪽에 위치.

  * 후위형(postfix) : 피연산자의 오른쪽에 위치.


    | 타입   | 설명                          | 사용예   |
    | ------ | ----------------------------- | -------- |
    | 전위형 | 값이 참조되기 전에 증가시킨다 | j = ++i; |
    | 후위형 | 값이 참조된 후에 증가시킨다.  | j = i++; |
    
    #### 그러나, 증감연산자가 수식이나 메서드 호출에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우, 전위형과 후위형의 차이가 없다.



* 예제:

  ```java
  class Ex3_2 {
    public static void main(String args[]) {
      int i=5, j=0;
        
      j = i++;
      System.out.println("j=i++; 실행 후, i=" + i + ", j="+ j);
      
      i=5;      // 결과를 비교하기 위해, i와 j의 값을 다시 5와 0으로 변경.
      j=0;
      
      j = ++i;
      System.out.println("j=++i; 실행 후, i="+ i +",j="+ j);
    }
  }
  ```

  > 이 코드의 결과 값:
  >
  > j=i++; 실행 후, i=6, j=5
  >
  > j=++i; 실행 후, i=6, j=6
  >
  > * 위의 결과가 나오는 이유는, ++i(전위형)는 변수(피연산자)의 값을 먼저 증가 시킨 후 변수의 값을 읽어오고.
  >   후위형은 변수의 값을 먼저 읽어온 후에 값을 증가시키기 때문이다.

  

* 예제 2:

  ```java
  class Ex3_3 {
    public static void main(String args[]) {
      int i=5, j=5;
      System.out.println(i++);
      System.out.println(++j);
      System.out.println("i = " + i ", j = "+j);
    }
  }
  ```

  > 이 코드의 결과 값:
  > 5
  >
  > 6
  >
  > i = 6, j = 6
  >
  > 
  >
  > * 이 코드의 계산 과정

  ```java
  System.out.println(i++);
  System.out.println(++j);
  ```

  ↕️

  ```java
  System.out.println(i);
  i++;
  ++j;
  System.out.println(j);
  ```

  

## 06. 부호 연산자

#### 부호연산자란?

* '-' 이다.
* 피연산자의 부호를 반대로 변경한 결과를 반환한다. (양수➡️음수 , 음수➡️양수 )
* 부호 연산자 중엔, '+'도 있지만, 쓰이는 경우는 거의 없음.
* **boolean형과 char형을 제외한 기본형에만 사용할 수 있다.**

```java
class Ex3_4 {
  public static void main(String[] args) {
    int i = -10;
    i = +i;
    System.out.println(i);
    
    i= -10;
    i = -i;
    System.out.println(i);
  }
}
```

> 이 코드의 결과값:
>
> -10
>
> 10



## 07. 형변환 연산자

#### 형변환이란?

* 변수 또는 상수의 타입을 다른 타입으로 변환하는 것.

* 형변환 방법: 형변환 하고자 하는 변수나 리터럴 앞에 변환하고자 하는 타입을 괄호와 함께 붙여준다.
  Ex) (타입)피연산자

  * 이 때 사용 되는 괄호()는 '캐스트 연산자' 혹은 '형변환 연산자'라고 한다.

  * 형변환을 '캐스팅(casting)'이라고도 한다.

    >  Ex) double d = 85.4;
    >
    > int score = (int)d;
    >
    > 
    >
    > * 단계별 진행 과정
    >
    > Int score = (int)d; ➡️ int score = (int)85.4; ➡️ int score = 85;

* 형변환의 다양한 예시

  | 변환        | 수식      | 결과  |
  | ----------- | --------- | ----- |
  | int ➡️ char  | (char)65  | 'A'   |
  | char ➡️ int  | (int) 'A' | 65    |
  | float ➡️ int | (int)1.6f | 1     |
  | int ➡️ float | (float)10 | 10.0f |

  

* 예제:

  ```java
  class Ex3_5 {
    public static void main(String[] args) {
      double d = 85.4;
      int score = (int)d;
      System.out.println("score="+ score);
      System.out.println("d="+ d);
    }
  }
  ```

  > 이 코드의 결과:
  >
  > Score=85
  >
  > d=85.4 ⬅️ 형변환 후에도 피연산자에는 아무런 변화가 없다.



## 08. 자동 형 변환

* 서로 다른 타입간의 대입이나 연산 시, 형변환으로 타입을 일치시키시는 것이 원칙이지만,
  **편의상의 이유로 형변환을 생략 할 수 있다.** 이 때, **컴파일러**가 생략된 형변환을 **자동적으로 추가**해준다.

* 변환 생략이 가능한 경우


  ```java
  float f = 1234;  // float f = (float)1234;에서 (float)가 생략됨.
  ```

  > 위의 식의 경우, 우변은 int타입의 상수이고, 이 값을 저장하려는 변수의 타입은 실수인 float이다.
  > 서로 타입이 달라서 형변환이 필요하지만, float타입의 변수는 1234라는 값을 저장하는 데 **문제가 없어** 편의상 생략 하였다.

* 변환 생략이 불가능한 경우

  ```java
  byte b = 1000; // 에러. byte타입의 범위 (-128 ~ 127)를 벗어난 값의 대입
  ```

  > 위의 식의 경우, 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려 했기에, 형변환을 생략하면 에러가 발생.
  >
  > * 나타나는 에러메세지: 'incompatible types: possible lossy conversion from int to byte'
  >
  > * 그러나 위 식의 경우, 명시적으로 형변환 할 때, 프로그래머가 의도적으로 한 것으로 간주하고 컴파일러에서 에러가 발생하지않는다.
  >
  >   ```java
  >   byte b = (byte)1000; // Ok. 그러나 값 손실이 발생해서 변수 b에는 -24가 저장됨.
  >   ```


따라서 형변환의 경우,

#### 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환 된다.



| 1byte  | 2byte   | 4byte | 8byte  | 4byte   | 8byte  |
| ------ | ------- | ----- | ------ | ------- | ------ |
| byte ➡️ | short ➡️ | int ➡️ | long ➡️ | float ➡️ | Double |
|        | Chat ↗️  |       |        |         |        |

> 화살표 왼쪽에서 오른쪽으로의 변환은 **자동 형변환이 적용** 되고,
> 오른쪽에서 왼쪽으로의 변환은 **반드시 형변환 연산자를 써야한다.**

