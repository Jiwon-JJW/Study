# OS 및 일반적인 지식

## OS(Operating System : 운영체제)

* OS는, IT에서 중요한 S/W이다. 최근에는 H/W보다 S/W가 IT기술 발전에 더 크게 기여하고 있다.
* 다양한 스마트 디바이스들이 존재하고, 기업이 제공하는 플랫폼 위에서 다양한 어플리케이션을 개발한 시대이므로, OS의 기본을 이해하고 나면 활용할 수 있는 기술들이 많아진다.
  

### 1. 운영체제(OS)란?

* 운영체제(OS: Operating System): 컴퓨터 시스템의 자원들을 효율적으로 관리 하며, 사용자가 컴퓨터를 **편리하고 효과적으로 사용할 수 있도록 환경을 제공(abstraction을 제공)하는 여러 프로그램의 모임**. 
  * ex) CPU - process가 관리, Memory - address space가 관리, Disk - file이 관리.
* 컴퓨터와 하드웨어(CPU, I/O) 바로 위에 설치되어, 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 중개자 역할을 한다.
  자원의 공유 및 분배를 위한 policy를 제공.



#### Abstraction?

* 프로그램(Program):
  컴퓨터를 실행시키기 위한 일련의 순차적으로 작성된 명령어 모음. 컴퓨터 시스템의 disk와 같은 secondary storage에 바이너리 형태로 저장.

* 프로세스(Process):

  실행되고 있는 프로그램의 추상화(abstraction). Progran counter, stack, data section 등을 포함.

* 주소공간(Address Space):
  프로세스가 차지하는 메모리 공간. Protection Domain으로써, 서로의 주소공간을 침범할 수 없다.

* 파일(File):

  프로세스에서 읽고 쓸 수 잇는 Persistent storage.

* 포트(Port):
  컴퓨터간에 메세지를 주고받는 communication end point. 여러가지 프로세스가 네트워크 안에서 섞이지 않게 만들어 준다.

* 커널(Kernel): 

  운영체제의 핵심 부분. 시스템의 모든 것을 완전하게 통제하는 기능을 한다.

  * 커널의 역할: 보안, 자원 관리, 추상화



#### 운영체제의 역할

1. 프로그램들이 자원(resource)을 필요로 할 때 자원을 할당해준다.

   자원은 한정적이므로, 효율적인 관리를 해준다.
   (자원: CPU 시간, 메모리 공간, 파일 저장 공간, 입출력 장치 등등)

2. 각각 자원을 할당받은 프로그램들이 서로의 영역을 침범 혹은, 자원을 침범하지 않게 하고, 컴퓨터의 부적절한 사용을 방지하는 **제어프로그램의 역할**을 한다.



#### 운영체제의 구조

* 멀티 프로그래밍(Multi-programming)
  * 컴퓨터 내에 CPU와 다양한 I/O장치들이 있다.
    CPU에 들어 간 프로그램이 하나 밖에 없을 때, 프로그램이 입력 대기 상태일 경우, CPU는 작동을 하지 않아 효율성이 떨어진다.
    이를 해결 하기 위해 메모리에 여러 개의 Job(프로그램,프로세스 통칭)을 저장해 두고, 하나의 Job 실행 중 I/O작업 등이 발생해 유휴 시간이 생겼을 때, 다른 Job을 시작하여 CPU의 효율성을 증가 시킴.
    이로서 여러개의 작업(Job)을 메모리에 동시에 유지시킨다.
  * 다만, User가 실행중인 작업에 대해 관여할 수 없어, 다른 작업이 수행되려면 현재 수행 중인 작업이 I/O를 해야한다.(자발적 양보(voluntary yield)에 의존)
    우선순위가 높은 작업을 먼저 처리 해야할 때 문제가 발생할 가능성이 높으며, 이는 Job Scheduling으로도 해결 할 수 없음.
* 타임 셰어링(Time-sharing)
  * 멀티 프로그래밍에서 확장된 개념. 멀티 태스킹(Multi-tasking)이라고도 함.
  * CPU가 **스케쥴링**을 통해 작업들을 빠르게 Switching 하면서, 마치 동시에 프로그래밍이 구성되는 것 처럼 느껴지게 한다.
  * 메모리가 모자라는 경우, 스와핑(swapping)을 통해 프로세스를 가상메모리(Virtual Memory)에 저장한다. 



### 2. 운영체제의 작동 (Operating System Operations)

* 현대의 운영체제는 인터럽트(Inturrupt)를 기반으로 한다.
  실행할 프로세스가 없다면 운영체제도 작동을 하지 않고 기다리고, 어떠한 인터럽트나 트랩이 발생하면서 이벤트가 발생한다.

  * 인터럽트: 인터럽트 발생 시,(ex: 컴퓨터 부팅 시, 암호입력) 인터럽트의 대응이 끝난 후, 그 다음 명령어를 수행하거나 대기상태로 돌입하기 위해OS는 명령어의 주소를 저장한다.

    1. 외부 인터럽트(H/W inturrupt): 키보드, 마우스 등과 같이 외부에 기반하여 발생하는 인터럽트.

    2. 내부 인터럽트(S/W inturrupt): 프로그램 안에서 실행되는 인터럽트.

       

* 하드웨어 보안
  * 듀얼모드(Dual-Mode Execution)

    * 운영체제가 유저모드(User mode)와 커널 모드(Kernel mode)로 나누어서 동작하는 것.

    * 유저 어플리케이션이 운영체제의 중요한 데이터에 접근해서 변경하는 것을 막기 위하여 두 가지 모드로 나눈 것이다.

      > User Mode:
      >
      > * Kernel 모드에 비해 낮은 권한의 실행모드
      > * 어플리케이션이 실행 되는 모드. 시스템에 영향을 주는 연산은 커널모드에서만 실행 가능 해, 하드웨어 보안 유지.
      > * Privilege 명령어 실행 불가능.
      > * CPU 내부에 모드 비트(mode bit)를 두어 사용자 프로그램을 감시한다.
      >   (각각의 명령어에 mode bit가 심어져 있으며, 명령어의 mode bit와 시스템 상의 mode bit가 같을 시에만 명령어 사용 가능.)

      

      > Kernel Mode:
      >
      > * 모든 권한을 가진 실행 모드
      > * 운영체제가 실행 되는 모드
      > * Privilege명령어 실행 및 레지스터 접근 가능.
      >   ex) I/O 장치 제어 명령어, 메모리 관리 레지스터 CR3

    * 유저 어플리케이션이 커널 모드에서만 제공되는 인스트럭션을 사용하려는 경우, 유저 모드 프로세스 내에서 비트(Bit)를 변경하는 **시스템 콜(System call)**을 실행한다.

      > 시스템 콜(System call):
      > OS의 커널이 제공하는 서비스에 대해, 응용프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스.
      > 프로그래밍 언어에서 지원하지 않는 기능에 대하여 운영체제의 루틴을 호출하여 이용하는 것.
      >
      > ![img](https://blog.kakaocdn.net/dn/oYzTi/btqyXq5GNUC/T5KVZpgkaS1z1FpkegbKhK/img.png)



## 스케줄링

#### 스케줄링이란?

* 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에 할당하는 작업을 의미.
  다중 프로그램을 가능하게 한다.

* 프로세스가 생성되어 완료될 때 까지 프로세스는 여러종류의 스케쥴링 과정을 거치는데,
  이 때의 스케줄링의 종류로는 장기 스케줄링, 중기 스케줄링, 단기 스케줄링이 있다.

  | 이름          | 설명                                                         |
  | ------------- | ------------------------------------------------------------ |
  | 장기 스케줄링 | 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할것인가를 결정하여 준비상태 큐로 보내는 작업.<br />작업 스케줄링 또는 상위 스케줄링이라고도 하며, 이러한 스케줄링은 작업 스케줄러에 의해 수행. |
  | 중기 스케줄링 | 어떤 프로세스들이 CPU를 할당 받을 것인지 결정하는 작업.<br />CPU를 할당 받으려는 프로세스가 많을 경우 프로세스를 일시 보류 시킨 후 활성하 하여 일시적으로 부하를 조절. |
  | 단기 스케줄링 | 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업.<br />프로세서 스케줄링 또는 하위 스케줄링이라고도 한다.<br />프로세서 스케줄링 및 문맥 교환은 프로세서 스케줄러에 의해 수행. |



#### 스케줄링의 목적

* 스케줄링은 CPU나 자원을 효율적으로 사용하기 위한 정책으로, 아래와 같은 목적을 가지고있다.
  1. 공정성: 모든 프로세스에 공정하게 할당.
  2. 처리율(량)증가: 단위 시간당 프로세스를 처리하는 비율(양)을 증가.
  3. CPU 이용률 증가: 프로세스 실행과정에서 주 기억장치를 액세스 하거나, 입출력 명령실행 등의 원인에 의해 발생할 수 있는 CPU 낭비시간을 줄이고, CPU가 순수하게 프로세스를 실행하는 시간 비율을 증가.
  4. 우선순위 제도: 우선순위가 높은 프로세스를 먼저 실행
  5. 오버헤드 최소화: 오버헤드를 최소화
  6. 응답시간 최소화: 작업을 지시하고,반응하기 시작하는 시간을 최소화.
     (* 응답시간(Respinse Time): 하나의 요청에 첫번째 응답이 나올 때 까지의 시간 )
  7. 반환시간 최소화: 프로세스를 제출한 시간부터 실행이 완료 될 때 까지 걸리는 시간을 최소화.
     (* 반환시간(Turnaround Time): 메모리에 적재되기 위해 기다린 시간, 준비상태 큐에서 대기한 시간, CPU에서 실행하는 시간, 입출력 시간을 합친 시간)
  8. 대기시간 최소화: 프로세스가 준비상태 큐에서 대기하는 시간을 최소화.
     (* 대기시간(Waiting Time): 준비 상태 큐에서 대기하는 시간)
  9. 균형있는 자원의 사용: 메모리, 입출력 장치등의 자원을 균형있게 사용.
  10. 무한 연기 회피: 자원을 사용하기 위해 무한정 연기되는 상태를 회피.



### 프로세서 스케줄링의 기법

#### * 비선점 스케줄링

* 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법.
* 프로세스가 CPU를 할당 받으면, 해당 프로세스가 완료될 때 까지 CPU를 사용. 
* 특징:
  * 프로세스 응답시간의 예측이 용이.
  * 일괄 처리 방식에 적합.
  * 중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우가 발생할 수 있다.
* 비선점 스케줄링의 종류:
  * FCFS, SJF, 우선순위, HRN, 기한부 등의 알고리즘.



#### * 선점 스케줄링

* 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때, 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법.

* 우선 순위가 높은 프로세스를 빠르게 처리할 수 있다.

* 특징:

  * 빠른 응답시간을 요구하는 대화식 시분할 시스템에 사용 됨.

  * 많은 오버헤드를 초래.

  * 선점이 가능하도록, 일정 시간 배당에 대한 인터럽트용 타이머 클록이 필요하다.

    >  인터럽트용 타이머 클록:
    > 하나의 시스템 내에서 동작하는 장치들을 감시하기 위해 주기적인 신호를 발생하는 것.
    > 하나의 프로세스가 자원을 독점하지 못하도록 방지하기 위해 사용.

* 선점 스케줄링의 종류:

  * 라운드 로빈, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등의 알고리즘이 있다.





## 터미널 사용 방법

#### 터미널이란?

* 컴퓨터와 사용자 간의 서로 소통시켜주는 인터페이스. 컴퓨터와 소통하기 위해서 키보드를 사용하는 것을 말한다.
* Shell을 기본적으로 사용하고 있으며, Linux OS에서는 기본적으로 bash,tcsh등이 사용되고 Window에서는 cmd를 기반으로 사용되고 있다.
  * Shell: 사용자가 명령을 내리면, 그 명령을 해석하여 커널에 전달해주는 인터페이스 역할. GUI와, CLI로 나뉜다.
    * GUI(Graphic User Interface): 그래픽 유저 인터페이스. 
      사용자가 편리하고 직관적으로 알아 볼 수 있도록 그래픽으로 입출력등의 기능을 수행해, 송출한다.
      ex) 윈도우를 처음 켰을 때 보이는 아이콘들.
    * CLI(Command Line Interface): 명령어 기반 인터페이스.
      터미널 등의 프로그램을 통해서 문자열을 입력하고, 문자로 반환된 결과를 확인하는 인터페이스.



#### 사용하는 이유

* 일부 작업의 경우, 그래픽 응용 프로그램 및 메뉴보다 터미널을 사용하여 작업을 완료하는 것이 빠르기 때문.
* 더 많은 명령과 스크립트에 액세스 할 수 있기 때문.



#### 사용 방법

* Window 나 UNIX내의 응용프로그램 검색 창에 CMD 혹은 Terminal 입력 후, 원하는 명령어를 입력한다.
  Window 내에선 터미널을 사용할 수 있는 프로그램을 CMD / 명령 프롬프트 라고 불리며,
  UNIX 내에선 터미널을 사용할 수 있는 프로그램을 터미널 이라고 부른다.





## 메모리

### 1. 메모리의 종류

![image](https://user-images.githubusercontent.com/69128652/95991255-81fa0a80-0e67-11eb-9c99-c2f197987273.png)

| 휘발성 메모리            | 비 휘발성 메모리     |
| ------------------------ | -------------------- |
| RAM (랜덤 액세스 메모리) | ROM(고정 기억 장치)  |
| DRAM (동적 램)           | NVRAM(플래시 메모리) |
| SRAM                     | MRAM                 |
| 내용 주소화 기억 장치    |                      |

* RAM(Random Access Memory) :

  * 전원 공급을 끊으면 기록한 데이터가 소실되는 메모리. 휘발성 메모리 이다.
    프로그램이나 데이터를 일시적으로 저장하는 용도로 사용 됨.

  * 크게 SRAM(Static RAM) 과 DRAM(Dynamic RAM)으로 분류 된다.

    * SRAM: 

      * flip-flop circuit을 사용해 데이터를 유지.
      * 전원을 공급하면 데이터를 유지할 수 있는 플립플롭 회로를 사용한 셀구조.
      * 제어가 쉽고, 읽기/쓰기 동작이 고속이다.
      * 셀 면적이 크기때문에 대용량화에 적합하지 않음. 가격이 비싸다.

    * DRAM:

      * Capacitor를 이용해서 데이터를 유지.

      * 커패시터에 전하를 축적함으로 인하여 데이터를 유지하는 커패시티형 셀구조.

      * 정기적으로 리플레시 신호를 주지 않으면 데이터가 소실됨. 제어가 복잡하다.

      * 셀 면적이 작기 때문에 대용량화에 적합하다. 가격이 SRAM보단 저렴하다.

      * 대표적으로 SDRAM 이라는 DRAM이 존재한다.

        * SDRAM(Synchronous DRAM):
          Bus 속도를 빠르게 유지하는 상태로 동작할 수 있도록 만든 메모리.
          시스템의 clock 속도와 동기화(synchronous)가 가능하므로, CPU가 처리할 수 있는 양이 증가한다.

          > DDR SDRAM(Double Data Rate SDRAM):
          > SDRAM보다 2배(double) 빨리 동작한다.
          > 동일 시간에 데이터를 2배로 처리가 가능하기 때문에 효율이 높다.



* ROM(Read Only Memory) :

  * 읽기 전용 메모리. 전원 공급이 끊어져도 기록한 데이터는 소실되지 않는다. 비휘발성 메모리이다.
    다시 작성할 필요가 없는 프로그램이나, 데이터의 저장에 사용된다.

  * 크게 mask ROM 과 PROM(Programmable ROM)으로 나뉜다.

    * Mask ROM: 

      * 일반적인 ROM. 
      * 회사에서 ROM 제작시 데이터를 저장해 두고, 후에 지우거나 덮어씌우는 것이 불가능하다.

    * PROM :

      * 사용자가 바로 데이터를 기록할 수 있는 ROM.

      * OTP, EPROM, EEPROM으로 나뉜다.

        * OTP(One Time PROM) : 
          1회만 쓰기(수정)가 가능한 ROM. 한 번 수정하게 될 경우, 데이터 수정이 불가능하다.

        * EPROM(Erasable PROM) : 
          저장되어 있는 데이터를 쓰고 지울 수 있는 ROM. 데이터를 지우는 방법에 따라 EEPROM, UVEPROM 으로 나뉜다.

          > EEPROM(Electrically Erasable PROM): 
          > 고전압(high voltage)으로 데이터를 지우고, 삭제된 공간에 데이터를 다시 기록할 수 있는 메모리.
          > 비교적 지우는 속도가 느리다.

          

          > UVEPROM(Ultra-Violet EPROM): 자외선을 이용하여 데이터를 지운다.

* Flash Memory:

  * EEPROM의 한 종류. 기존 PROM 종류보다 더 빠르게 기록/ 삭제가 가능한 메모리.
  * 구조에 따라서 NOR과 NAND형 메모리로 분류 된다.
    * NOR: 
      * 데이터 유지에 있어서 에러가 적게 발생한다.
      * 지우기 속도가 느려서, 고속화에 적용되지 못함.
      * 셀 면적이 크기 때문에, 대용량화가 어렵다.
    * NAND:
      * 셀 면적이 작기 때문에, 대용량화에 적합하다.
      * 휴대용 음악 플레이어, 핸드폰 등에서 데이터 저장 용도로 사용된다.



### 2. 메모리 계층 구조 (Memory Hierarchy)

![image](https://user-images.githubusercontent.com/69128652/96000303-b5419700-0e71-11eb-82c9-dd2b3fdac552.png)

* 메모리를 필요(대부분의 경우, CPU가 메모리에 빨리 접근하기 위함)에 따라 여러가지 종류로 나누어 둠(계층화)을 의미한다.
* 속도가 느리고 용량이 큰 기억장치의 내용 중, CPU가 자주 사용하는 데이터를 속도가 빠른 기억장치로 옮겨 놓고 사용함으로써, 
  전체적인 기억장치의 액세스 속도를 개선하는 전략을 사용한다.
* 기억 장치의 성능 평가 기준에는, 액세스 속도, 용량, 가격이 있는데, 이 세가지 특징은 상반되는 경우가 많다.
* 보통 액세스 속도가 빠를수록 용량이 작아지고, 가격이 비싸진다.



#### 메모리 계층 구조의 필요성

* 자주 쓰이는 데이터는 계속 쓰인다. (참조의 지역성): 
  자주 쓰이는 데이터는 전체 데이터의 일부이기 때문에, 상위 메모리의 용량이 하위 메모리의 용량보다 작아도 된다.
* 디코딩(명령 해독 단계) 속도:
  여러 개의 메모리를 사용 할 시, CPU는 자신이 원하는 메모리에 접근 해야한다.
  이 과정에서 컨트롤 신호를 해석해야하는데, 메모리가 클수록 해당 비용이 증가한다.
* 경제성:
  상위 계층의 메모리일 수록 가격이 올라간다.



### 3. 가상 메모리

#### 가상메모리 (Virtual Memory)란?

* 메모리를 관리하는 방법의 하나로, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식을 말한다.
  운영 체제에서 디스크 공간을 메모리 처럼 활용할 수 있는 기능을 제공하고, 디스크 상에 존재하는 이런 파일을 Paging file 이라고 한다.
* 멀티태스킹 운영체제에 흔히 사용 되며, 실제 주기억장치(RAM)보다 큰 메모리 영역을 제공하는 방법으로 사용된다.
* 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽거나 쓸 때에만 물리주소로 바꿔준다.
  * 가상 주소(Virtual address): 프로세스가 참조하는 주소.
  * Physical address: 실제 메모리 주소
* CPU는 가상 메모리를 다루고, 실제 해당 주소 접근 시 MMU 하드웨어 장치를 통해 물리 메모리에 접근한다.
  하드웨어 장치를 사용해야 주소 변환이 빠르기 때문이다.
  * MMU(Memory Management Unit): CPU에서 코드 실행 시, 가상 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치.
    매핑(mapping)을 지원한다.



#### 가상 메모리와 실제 메모리의 관계

* 가상 메모리 안의 프로그램이 실행 될 경우, 실제 메모리에 머물러 있어야한다.
* 전체가 실제 메모리에 있어야하는 것이 아닌, 현재 실행되어야하는 부분만 있으면 되므로, 실제 메모리 용량보다 큰 프로그램이 가상메모리에서 작동한다.



#### 매핑(Mapping)

* 매핑(mapping): 
  * MMU하드웨어에 의해 지원되는 기능.
  * 가상메모리와 실제 메모리 사이의 중계를 맡고 있다.
  * Paging과 Segmentation, 이 두가지 방식을 혼합한 방법. 총 3가지로 분류된다.



#### 페이징(Paging) 기법

* 페이징 기법은 컴퓨터가 메인 메모리에서 사용하기 위해 데이터를 저장하고 검색하는 메모리 관리 기법.

* 페이징 기법으로 컴퓨터의 물리적 메모리는 연속적으로 할당되어 존재할 필요가 없으며,
   연속적으로 존재하지 않는 물리적 메모리라도 페이징 기법을 통해 연속적으로 존재하는 것처럼 이용될 수 있다.

* 가상 메모리 상의 주소 공간을 일정한 크기로 분할.
  주소 공간은 페이지 단위로 나뉘어져 있으며, 실제 기억 공간은 페이지 크기와 같은 프레임으로 나누어 사용함.

  * Frame: 물리 메모리를 일정한 크기로 나눈 블록

  * Page: 가상 메모리를 일정한 크기로 나눈 블록.

    > Frame과 Page는 동일한 크기로 관리 됨.
    > 페이지의 크기는 시스템에 따라 다르다. (일반적으로 4Kbyte)

* 물리메모리(Frame)와 가상메모리(Page)를 대응하기 위해, page mapping 과정이 필요하다.
  이를 위해 페이지 테이블(Page table)을 설정하는 것이 필요하다.

  * 페이지 테이블(page table):
    * 페이징 기법에서 사용되는 자료구조. 프로세스 페이지 정보를 저장하고 있는 테이블.
    * 하나의 프로세스는 하나의 페이지 테이블을 가진다.
    * 색인(페이지 번호)과 
      내용(페이지에 할당된 물리메모리(Frame)의 시작주소. 시작주소와 페이지 주소를 결합해, 물리메모리 주소를 알 수 있다.)
      으로 구성되어있다.

* 장점:

  * 페이징 기법 사용 시, 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화(External fragmentation)를 해결 할 수 있다.
  * 코드를 쉽게 공유할 수 있음.

* 페이지 단위를 작게하면 내부 단편화(Internal fragmentation)를 해결 할 수 있지만, 남는 공간이 적어지기 때문에 
  page mapping 과정이 증가하므로, 서로 trade off 관계에 있다.



### 세그멘테이션(Segmentation)

* 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할하고 메모리를 할당하여 주소를 변환한다.
* 각각의 세그먼트들은 연속적인 공간에 저장되어있다.
* 세그먼트들의 크기가 서로 다르기 때문에, 메모리를 페이징 기법처럼 미리 분할해 둘 수 없다.
* 메모리에 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상메모리 관리 기법.
* mapping을 위해 세그먼트 테이블이 필요하다.
* 장점:
  * 하나의 세그먼트 단위로 메모리를 통제할 수 있다. == 내부 단편화가 발생하지 않는다.
* 단점:
  * 서로 다른 크기의 세그먼트들에 대해 동적인 관리를 진행하므로, 해당 작업들을 반복하다 보면 외부 단편화가 생길 수 있는 가능성이 매우 크다.



#### 페이징과 세그멘테이션의 차이점

![스크린샷 2020-10-15 오전 12 03 50](https://user-images.githubusercontent.com/69128652/96007878-e9b95100-0e79-11eb-9691-953fb50deb5a.png)





## 프로세스 

### 1.프로세스(Process)란?

* 컴퓨터에서 연속적으로 **실행되고 있는(실행중인)** 컴퓨터 프로그램.
  프로세스의 관리는 운영체제의 중요한 부분이다.
* 스케줄링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 쓰임.
* 여러개의 프로세서를 사용하는 것을 **멀티 프로세싱**,
  같은 시간에 여러개의 프로그램을 띄우는 시분할 방식을 **멀티태스킹** 이라고 한다.
* 실행하면서 stack pointer, data, text, register 등이 끊임없이 변한다.
* job, task등으로 불리기도 함.



#### 프로세스 상태

* 생성(create): 프로세스가 생성되는 중이다.
* 실행(running): 프로세스가 CPU를 차지하여 명령어들이 실행되고 있다.
* 준비(ready): 프로세스가 CPU를 사용하고 있지는 않지만, 언제든지 사용할 수 있는 상태.
  CPU가 할당되기를 기다리고 있다.
  일반적으로 준비상태의 프로세스 중 우선순위가 높은 프로세스가 CPU를 할당받음.
* 대기(waiting): 보류(block)라고 부르기도 한다.
  프로세스가 입출력 완료, 시그널 수신 등 어떤 사건을 기다리고 있는 상태.
* 종료(terminated): 프로세스의 실행이 종료 되었다.



#### 프로세스의 상태 전이

* 하나의 프로그램 실행 시, 그 프로그램에 대응되는 프로세스가 생성되어 준비리스트의 끝에 들어감.
* 준비 리스트 상의 다른 프로세스들이 CPU를 할당받아 준비 리스트를 떠난다.
* 점차 준비 리스트의 앞으로 나가게 되고, 언젠가 CPU를 사용할 수 있게 됨.
  * 디스패치(dispatch):
    준비 리스트의 맨 앞에 있던 프로세스가 CPU를 점유하게 되는 것. ( 준비 상태에서 실행 상태로 바뀌는 것.)
  * 보류(block):
    실행 상태의 프로세스가 허가된 시간을 다 쓰기 전에 입출력 동작을 필요로 하는 경우, 프로세스는 CPU를 반납하고 보류상태로 넘어가게 되는 현상.
  * 깨움(wakeup):
    입출력 작업 종료 등, 기다리던 사건이 일어났을 때 보류 상태에서 준비 상태로 넘어가는 과정.
  * 시간제한(timeout):
    프로세스가 프로세서를 독점하지 못하기 위해 clock interrupt를 둔 것.
    프로세스가 일정 시간 동안만(시분할 시스템의 time slice) 프로세서를 점유할 수 있도록 한다.



#### 프로세스 블럭 (PCB: Process Control Block)

* 프로세스에 대한 모든 정보가 모여있는 운영체제 커널의 자료구조.
* 작업제어 블록(TCB:Task Control Block) 또는 작업 구조라고도 한다.
* 수행 중인 프로세스를 나갈 때, 이 프로세스의 정보를 저장하여, 이후에 이전에 수행했던 다음부터 작업할 수 있도록 도와주는 저장 장소.



* 프로세스의 상태, 번호(PID), CPU 레지스터 등 다양한 정보가 저장되어 있다.
  * 프로세스 식별자(Process ID)
  * 프로세스 상태(Process State):
    * 생성(creat), 준비(ready), 실행(running), 대기(waiting), 완료(terminated) 상태가 있다.
    * 유예 준비 상태(suspended ready), 유예 대기 상태(suspended wait) 는 스택이 아닌, disk에 저장된다.
  * 프로그램 계수기(Program Counter): 프로그램 계수기는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킴.
  * CPU 레지스터 및 일반 레지스터
  * CPU 스케줄링 정보: 우선순위, 최종 실행시각, CPU 점유 시간 등
  * 메모리 관리 정보: 해당 프로세스의 주소 공간 등
  * 프로세스 계정 정보: 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등
  * 입출력 상태 정보: 프로세스에 할당된 입출력 장치 목록, 열린 파일 목록 등.



#### 프로세스 큐(Queue)

* 프로세스가 여러 개의 작업을 진행 할 때, 순서를 대기하는 곳.
* 준비 큐, 대기 큐, 실행 큐 등의 자료 구조가 있다.
  * Job Queue: 하드 디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐.
  * Ready Queue: CPU 점유 순서를 기다리는 큐.
  * Device Queue: I/O를 하기 위한 각각의 여러 장치를 기다리는 큐가 그에 맞춰서 각각 존재함.
* 각 큐 내부에 저장된 실제 데이터는, 각 프로세스의 PCB가 저장되어있다.
  순서를 기다리는 공간이 있는 만큼, 순서를 정해주는 알고리즘이 있는데, 이를 스케줄링(Scheduling) 이라고 한다.







### 2. 프로세스간 통신(IPC: Inter-Process Communication)

* 프로세스들 사이에 서로 데이터를 주고받는 행위 혹은, 그에 대한 방법이나 경로.
  컴퓨터 내부에서 보다 더 효율적으로 정보를 주고받기 위해 통신한, 통신의 일종.
* [프로세스 <-> 프로세스]가 [서버 <-> 클라이언트]와 유사하기 때문에, 인터넷 통신을 IPC의 확장으로 이해해도 좋다. 
* 프로세스간의 통신을 위해 PIPE 같은 개념이 생성되었다.
* 프로세스는 생성되면서 PC(Program Counter)를 포함하여 메모리 공간들을 복사하여 자원을 할당한다.
  * PC(Program Counter): 프로그램 카운터. 다음에 수행해야하는 명령어의 주소를 가리키는 레지스터.



#### PIPE

* 프로세스는 메모리 공간을 복제하기 때문에, 통신을 위해 메모리 공간을 할당해주어야한다.
  이 때 사용되는 기술이 PIPEdlek.
* 통신을 위한 메모리 공간(버퍼)을 생성하여 프로세스가 데이터를 주고받게 끔 해준다.
* PIPE를 응용하면 외부 프로세스와 통신도 가능하지만, PIPE는 단방향 통신이다.
  그렇기 때문에 일반적으로 2개의 프로세스가 통신을 할 때, 2개의 PIPE를 사용하여 통신한다.
* 단방향 통신이라는 특성 때문에, 자원의 낭비가 심하다는 단점이 있다.
* PIPE의 종류:
  * 익명 파이프(Anonymous Pipe):
    * 외부 프로세스에서 사용할 수 없는 파이프. 부모프로세스가 자식 프로세스를 생성하는 경우, 파일 지정 번호를 상속받아 통신할 수 있다.
    * 사용이 제한적.
  * 네임드 파이프(Named Pipe):
    * 각 파이프에 이름과 권한을 부여하여 생성된 파이프.
      읽기/쓰기가 모두 가능하지만, 한번에 한 방향으로만 통신이 가능한 반이중통신.
    * 전이중통신을 읽기 위해서는 읽기 파이프, 쓰기 파이프를 각각 생성해야한다.
    * 다수의 클라이언트를 처리하기엔 비효율적이다.



#### Unix Domain Soket

* 소켓 함수와 기술을 그대로 사용한 것.
* 유닉스 영역(같은 시스템)의 통신에서 사용하며, 유닉스 서버에서 서버/클라이언트 환경을 만들 수 있다.
* 특징:
  * 서버/클라이언트 환경을 구축하는데 용이하다.
  * 중대형 어플리케이션에서 주로 사용.



#### 공유 메모리 (Shared Memory)

* OS가 제공하는 메모리를 프로세스들이 공유하는 메모리.
* 프로세스 A가 메세지를 공유 메모리에 전송 -> 프로세스 B가 공유 메세지를 읽음. 과 같은 방식 사용.
* 특징:
  * 대량의 정보를 다수의 프로세스에게 배포가 가능.
  * 빠르고 효율적임.
  * 공유 메모리 공간에 대한 접근 제어가 필요.



### 3. 프로세스와 스레드의 차이

* 프로세스: 생성되면서 메모리 공간 등을 복사하여 자원을 할당.
* 스레드: 메모리 공간과 자원들을 공유함.
  * 프로세스와 스레드를 생성하기 전, A의 변수를 선언 한경우:
    * 프로세스: A를 각각 1개씩 갖게된다.
    * 스레드: A를 공유한다.
* 이러한 특징으로, 시스템 자원을 효율적으로 관리하기 위해, 하나의 프로세스에서 스레드로 나눠가면서 작업을 진행하게 된다.
  * 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원의 효율적인 관리가 가능.
  * 프로세스 간의 통신보다 스레드 간의 통신의 비용이 적으므로, 작업들간의 통신 부담 줄임.
* 스레드를 활용하면, 자원의 효율성이 증가하지만, 스레드 간의 자원공유는 전역 변수를 이용하므로 동기화 문제에 신경 써야한다.
  (멀티 스레드의 경우, 프로그래머의 주의가 필요.)



## 스레드와 동시성

### 1. 스레드(thred)

* 프로세스 내에서 실행되는 흐름의 단위.

* 일반적인 경우, 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다.
  이를 멀티 스레드(multithread)라고 한다.

* 종류:
  스레드를 지원하는 주체에 따라 2가지로 나뉜다.

  * 사용자 레벨 스레드(User-Level Thread):

    * 커널 영역의 상위에서 지원 된다.

    * 사용자 레벨의 라이브러리를 통해 구현 되며, 라이브러리는 스레드의 생성 및 스케줄링에 관한 관리 기능을 제공.

    * 장점:
      동일한 메모리 영역에서 스레드가 생성/관리 되므로 속도가 빠르다.

    * 단점:
      여러개의 사용자 스레드 중 하나가 시스템 호출 등으로 중단될 경우, 나머지 스레드 전부가 중단된다.

      > 커널이 프로세스 내부의 스레드를 인식하지 못해, 해당 프로세스를 대기상태로 전환 시키기 때문이다.

  * 커널 레벨 스레드(Kernel-Level Thread):

    * 운영체제가 지원하는 스레드 기능으로 구현. 커널이 스레드의 생성 및 스케줄링을 관리한다.
    * 스레드가 시스템 호출 등으로 중단 되어도, 프로세스 내의 다른 스레드를 중단시키지 않고 계속 실행시켜준다.
    * 사용자 스레드에 비해 생성/관리 하는 것이 느리지만, 다중처리기 환경에서 여러개의 스레드를 각각 다른 처리기에 할당할 수 있다.

* 스레드 데이터:

  * 기본 데이터:
    * 자신만의 고유한 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택.
    * 코드, 데이터 파일 등의 기타 자원은 프로세스 내의 다른 스레드와 공유.
  * 특정 데이터(TSD: Tread-Specific Data):
    * 멀티 스레드 프로그래밍 환경에서, 모든 스레드가 프로세스 데이터를 공유하고 있지만, 개별 스레드 만의 자료 공간이 필요 할 경우
      사용되는 데이터.
    * 여러 스레드 라이브러리들이 지원하는 기능 중의 하나다.





### 2. 동시성

#### 동시성이란?

* 병행성(동시성 / Concurrency)라고도 한다.
* 운영체제가 프로세서 시간을 나눠서, 여러 프로세스를 빠르게 전환하여 실행하는 방식.
* 마치 프로세스 여러 개를 동시에 실행하는 것 처럼 보이게 하는 것.
* 다중 프로그래밍 시스템에서 가질 수 있는 성질이다.



#### 상호 배제(Mutal Exclusion)

* 단일 프로세스&스레드의 경우, 신경 쓸 일이 거의 없지만 여러 루틴이 동시 수행되며, 공유 리소스에 접근하게 되는 동시성 프로그래밍을 할 경우 

  상호 배제(Mutal Exclusion)문제를 조심해야한다.

* 공유 불가능한 자원을 동시에 사용해야할 경우, 
  발생할 수 있는 충동을 방지하기 위해 Critical Section을 만들고, 해당 영역에서 데이터를 사용하게끔 하는 방식을 사용.

  * 세마포어(Semaphore)
    * 여러개의 프로세스 또는 스레드가 동시 접근 하는 문제를 방지하기 위해 고안된 기능.
    * 리소스의 상태를 나타내는 카운터를 지정하여 다중 프로세스에게 행동을 조정 및 동기화 시키는 기술.
    * 여러 프로세스가 접근 시, 여러개의 Lock을 할당하여 동시에 허용 가능한 Counter의 제한을 둔다.
  * 뮤텍스(Mutex)
    * Lock을 가지고 있을 때에만 공유자원에 접근이 가능하게끔 하는 로직.
    * 여러개의 락을 두어 제한된 리소스 접근을 허용하는 세마포어와 달리, 한 개의 쓰레드/프로세스만 할당한다.
  * 세마포어와 뮤텍스의 차이점:
    * 적용: 세마포어는 시스템적 범위, 뮤텍스는 프로세스 내에서 적용 됨.
    * 사용: 세마포어는 동기화 대상이 하나 이상, 뮤텍스는 하나일 때 사용됨.
    * 뮤텍스는 프로세스 내의 스레드간 자원접근에 대하여 적용되며, Lock한 스레드가 Unlock도 해주어야함.
    * 세마포어는 Lock을 건 소유주가 아니더라도 Unlock이 가능.
  * 동기화 처리 로직은 Lock을 수반하기 때문에, 이 것이 여러 개의 작업 큐 내에서 걸릴 때 DeadLock이 생길 우려가 있음.
    * 데드락: 임계 영역 내의 전역 리소스에 대해 복수 개의 Lock에 의하여 처리가 지연되는 현상.





## 기본적인 네트워크 개념

### 네트워크란?

* Net+Work의 합성어로, 컴퓨터들이 통신 기술을 이용하여 그물망처럼 연결된 통신 이용 형태.
* 상호간에 정보를 교환할 수 있도록 유무선을 통하여 연결된 것.
* 케이블이나 전화선, 무선 링크 등으로 연결되어 동일한 프로토콜을 사용하는 디바이스들의 집합.



#### 네트워크의 장단점

* 장점: 
  * 장소나 국가에 제한받지 않고 파일을 네트워크를 통해 공유 할 수 있다.
  * 미디어 스트림으로 사진, 음악 또는 비디오 등의 디지털 미디어를 재생할 수 있다.
  * 유선 PC가 아닌, 무선 네트워크를 통해 자유로운 공간에서 웹작업을 진행할 수 있다.
* 단점:
  * 파일 공유를 통해 바이러스나 악성코드, 원치않는 정보를 받을 수 있다.
  * 해킹으로 인한 개인 정보 유출이 가능하다.



#### 네트워크의 종류

![img](https://t1.daumcdn.net/cfile/tistory/995DCD465CAF21FD07)



* PAN(Personal Area Network) : 
  가장 작은 규모의 네트워크
* LAN(Local Area Network) : 
  근거리 영역 네트워크
* MAN(Metropolitan Area Network) : 
  대도시 영역 네트워크
* WAN(Wide Ares Network) : 
  광대역 네트워크
* VAN(Value Added Network) : 
  부가가치 통신망 정보의 축적과 제공, 통신속도와 형식의 변화, 통신 경로의 선택 등 
  여러 종류의 정보서비스가 부가된 통신망.
* ISDN(Integrated Services Digital Network) :
  종합정보 통신망(=BISDN) 전화, 팩스, 데이터 통신, 비디오 텍스 등 통신관련 서비스를 종합하여 다루는 통합서비스 디지털 통신망.
  디지털 전송방식과 광섬유 케이블을 사용.



#### 네트워크의 회선 구성 방식

* 컴퓨터와 여러대의 단말기들을 연결하는 방식.
  * 포인트 투 포인트 : 중앙 컴퓨터와 단말기를 일대일로 연결하여, 언제든 데이터 전송이 가능.
  * 멀티 드롭: 멀티 포인트 방식이라고도 한다. 다수의 단말기들을 한 개의 통신 회선에 연결.
  * 회선 다중 방식: 다중화 방식이라고도 한다. 여러대의 단말기들을 다중화 장치를 활용하여 중앙 컴퓨터와 연결.



#### 네트워크 데이터 교환 방식

* 회선 교환 방식: 통신을 원하는 두 지점을 교환기를 이용해, 물리적 접속시키는 방식. 음성 전화망이 대표적이다.
* 공간 분할 교환 방식: 기계식 접점과 전자 교환기의 전자식 접점 등을 이용하여 교환을 수행하는 방식. 음성 전화용 교환기가 대표적이다.
* 시분할 교환 방식: 전자부품이 갖는 고속성과 디지털 교환 기술을 이용해, 다수의 디지털 신호를 시분할적으로 동작시켜, 다중화 한다.



### TCP/IP 네트워크 종류

1. Protocol
   * 네트워크를 통합하여 컴퓨터끼리 통신을 하는 데 있어, 상호간에 정해진 약속의 집합 통신 절차,통신 규약.
2. RFC(Request For Comments)
   * 인터넷에 관한 기술 표준을 정하는 단체인 IETF가 정식으로 발행하는 문서.
   * 인터넷에 이용되고 있는 프로토콜, 여러 기술사양, 요건 을 RFC*** 와 같이 번호를 붙여서 공개한다.
3. LAN(Local Area Network)
   * 조직 단위, 사무실 등 한정된 영역을 연결하기 위한 지역적 네트워크.
   * 유지비용이 적게 들고, 직접 관리가 용이하다.
   * 초기 투자비용이 높다.
   * 속도: 100Mps
4. WAN(Wide Area Network)
   * 물리적으로 넓은 범위를 연결하는 광역 네트워크
   * 초기 설치비용은 적지만, 유지비용이 많이 든다.
   * 서비스 제공업체에서 관리를 하여, 관리가 용이.
   * 속도: 느린 연결



### TCP/IP 네트워크 기능

1. Layer

   * 기능적으로 비슷한 역할을 수행하는 protocol의 집합.
   * 동일한 layer 안에 여러개의 protocol이 있을 수 있다.

2. Model

   * 통신이 진행되는 순서에 따라 protocol layer를 배치한 것.
   * 현재 사용되는 Model: OSI 77 Layer Model, TCP/IP Protocol Model

3. OSI 7 Layer Model vs TCP/IP Model

   |      | OSI 7 Layer  Model | TCP/IP Model                    |
   | ---- | ------------------ | ------------------------------- |
   | 7    | Application        | Application                     |
   | 6    | Presentation       | Application                     |
   | 5    | Session            | Application                     |
   | 4    | Transport          | (Host - to Host)<br />Transport |
   | 3    | Network            | Internet                        |
   | 2    | Data Link          | Network Interface               |
   | 1    | Physical           | (Hardware)                      |

4. 각 Layer 소개

   | 계층  | Layer                   | 기능                                                         | 프로토콜                   |
   | ----- | ----------------------- | ------------------------------------------------------------ | -------------------------- |
   | 7계층 | Application (응용)      | 네트워크 데이터를 만들기 위한 사용자 응용 프로그램           | FTP, Telnet, http, smtp 등 |
   | 6계층 | Presentation (표현)     | Application에서 만들어진 데이터를 독립화 시키고<br />네트워크에 보편적인 데이터로 전환 | XDR 등                     |
   | 5계층 | Session (세션)          | Application간의 연결을 설정하거나 종료 시키고,<br />레이어 양단의 Application의 대화 교환, 종료를 담당함. | 인증, 세션설정 등          |
   | 4계층 | Transport (전송)        | 전송 될, 혹은 전송된 데이터의 품질을 보증하는 영역           | TCP, UDP                   |
   | 3계층 | Network (네트워크)      | 전송에 필요한 주소를 사용하는 영역                           | IP, ICMP 등                |
   | 2계층 | Data Link (데이터 링크) | 논리적인 데이터를 전송하기 위해 물리적인 형태로 변환하는 영역 | Ethernet 등                |
   | 1계층 | Physical (물리)         | 물리적 전송계층으로 네트워크 케이블,연결방식을 의미          |                            |

   * OSI 7 Layer Model 와 TCP/IP Model의 차이: Application, Presentation, Session layer 기능이 TCP/IP Model 에서는 통합되어있다.



### 네트워크 토폴로지(Topology)

* 물리적 토폴로지와 논리적 토폴로지로 나뉘어진다.
  * 물리적 토폴로지: 노드, 링크와 같은 네트워크를 구성하는 요소들의 배치로 인해 결정.
  * 논리적 토폴로지: 노드들 사이의 데이터 흐름에 따라 결정.
* 컴퓨터 네트워크 구성 요소들을 물리적으로 연결해 놓은 것. 혹은 그 연결 방식.
* 네트워크 구성 요소의 연결 방식에 따라 다양한 형태가 나타난다.



#### 토폴로지(Topology) 종류

* 링형(Ring)

  * 각 노드의 좌우의 인접한 노드와 연결되어 원형을 이루고 있는 네트워크 구조.
  * 장점: 단 방향 통신으로 신호 증폭이 가능하여 거리제약이 적음.
  * 단점: 노드의 추가 삭제가 용이하지 않고, 설치비용이 많이 듬.

  ![img](https://t1.daumcdn.net/cfile/tistory/2456B6395814B5791C)

* 성형(Star)

  * LAN에서 가장 널리 사용되는 물리적 토폴로지.
  * 중앙의 연결지점에 허브, 스위치, 라우터 같은 방지가 배치되며, 
    각 노드는 중앙에 위치한 주 노드를 통하여 다른 노드들과 통신할 수 있는 네트워크 구조.
  * 장점: 장애 발견이 쉽고, 관리가 용이.
  * 단점: 주 노드에 장애가 발생할경우, 전체 네트워크 사용이 불가능.

  ![img](https://t1.daumcdn.net/cfile/tistory/26145C3C5814B64D18)

* 버스형(Bus)

  * 버스라는 공유 통신 경로를 통해 연결된 클라이언트의 집합을 가리키는 네트워크 구조.
  * 장점: 노드의 추가 및 삭제가 용이.
    특정 노드의 장애가 다른 노드에 영향을 주지 않음.
  * 단점: 공통 배선의 대역폭을 공유하기 때문에, 노드 수가 증가하면 배선의 트래픽이 증가하여 네트워크 성능 저하.

  ![img](https://t1.daumcdn.net/cfile/tistory/214BB0395814B5792A)

* 망형(Mesh)

  * 모든 노드가 서로 일대일로 연결된 그물망 형태.
  * 다수의 노드 쌍이 동시에 통신할 수 있다.
  * 완전 연결형과 부분 연결형으로 나뉜다.
    * 완전 연결형: 스위칭 혹은 브로드 캐스팅이 필요 없지만, 노드가 추가 될 때마다 연결 수가 급격히 증가.
      노드 n개에 필요한 연결수는 n(n-1)/2
  * 장점: 하나의 노드에 장애가 발생해도 다른 노드에 영향을 주지않음.
    회선 장애에 유연한 대처가 가능.
  * 단점: 회선 구축 비용이 많이 든다.
    새로운 노드 추가시 비용부담 발생.

  ![img](https://t1.daumcdn.net/cfile/tistory/2149C3395814B57B2D)

  ![img](https://t1.daumcdn.net/cfile/tistory/254B70395814B57A2A)



