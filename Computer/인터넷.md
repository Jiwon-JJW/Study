# 인터넷(Internet)

* 웹의 핵심적인 기술.
  컴퓨터들이 서로 통신 가능한 거대한 네트워크.
* 1960년대 미육군에서 기금한 연구 프로젝트에서 시작 되었으며, 1980년 대 많은 국립대학과 비공개 기업의 지원으로 공공의 기반으로 변화됨.
* 인터넷을 지원하는 다양한 기술은 시간이 지남에 따라 진화해 왔지만, 작동 방식은 그다지 변하지 않음.
* 인터넷은 모든 컴퓨터를 연결하고 어떤 일이 있어도 연결상태를 유지할 수 있는 방법을 찾는 방법.

## 인터넷은 어떻게 작동될까요?

#### 단순한 네트워크

* 두 개의 컴퓨터가 서로 통신 할 때, 다른 컴퓨터와 물리적(보통 이더넷 케이블)으로 연결되거나, 무선(WiFi / Bluetooth)으로 연결 되어야 한다.
  * 1:1 연결 예:
    ![1:1연결](https://mdn.mozillademos.org/files/8441/internet-schema-1.png)





* 네트워크는 다양한 컴퓨터 이용자들이 사용하는 만큼, 원하는 만큼의 컴퓨터를 연결할 수 있는데
  이렇게 될 경우, 서로간의 컴퓨터를 연결하는 것이 매우 복잡해진다.
  ex) 10대의 컴퓨터를 연결하려는 경우, 컴퓨터 당 자신의 컴퓨터를 제외한 9개의 연결 플러그가 달린 45개의 케이블이 필요.
  * 다수의 연결 예:
    ![다수 네트워크 연결](https://mdn.mozillademos.org/files/8443/internet-schema-2.png)





* 위 처럼 복잡하게 연결되는 문제를 해결하기 위하여, 네트워크의 각 컴퓨터는 **라우터(Router)**라고 하는 특수한 소형 컴퓨터에 연결 된다.

  * 라우터에는 철도역의 신호원처럼, 주어진 컴퓨터에 **보낸 메세지가 올바른 대상 컴퓨터에 도착하는지 확인하는 기능**을 가진다.
  * 예로, 컴퓨터A가 컴퓨터 B에게 메세지를 보낼 때, 메세지를 라우터로 발송하여 라우터는 메세지를 컴퓨터 C로 배달되지 않도록 주의하며 컴퓨터 B로 전달 한다.
  * 만약, 이 라우터를 사용하게 된다면 위 처럼 복잡하게 컴퓨터끼리 연결하지 않고, 각 컴퓨터 당 1개의 케이블만 소요된다.
    각 컴퓨터는 한 개의 플러그만 필요하게 되며, 이 컴퓨터들을 연결해줄 한 개의 라우터만 10개의 플러그를 가지면 되는 셈이다.
    * 라우터와 각 컴퓨터간의 연결 예:

  

  ![라우터와의 연결](https://mdn.mozillademos.org/files/8445/internet-schema-3.png)



#### 네트워크 속의 네트워크

* 컴퓨터 >(연결)> 라우터 >(연결)>라우터<(연결)<컴퓨터
  의 형태로, 라우터 또한 작은 컴퓨터이기 때문에 서로간의 연결로 수백, 수천, 수십억 대로 연결을 무한히 확장할 수 있다.
  *  라우터간의 연결 예:
    ![라우터간의 연결](https://mdn.mozillademos.org/files/8449/internet-schema-5.png)



* 이러한 네트워크는 우리가 인터넷이라고 부르는 것에 매우 가까운 형태이지만, 이러한 연결은 같은 공간 내에 있는 기기간의 연결이 아니라, 다른 지역간의 연결이나 현재 있는 A의 위치에서 먼 곳에 위치한 B의 위치에 케이블을 연결하기는 불가능에 가까워, 물리적으로 한계를 맞게 된다.

* 이 문제를 해결하기 위하여 전화기 기반의 시설에 연결을 하게 된다.
  전화기 기반의 시설은 이미 세계 어느 곳과도 연결이 되어있으므로, 먼 곳에 위치한 라우터라도 연결이 가능 하기 때문이다.

* **우리의 네트워크를 전화 시설과 연결하기 위해서는, 모뎀(MODEM, MOdulator and DEModulator)이라는 특수 장비가 필요하다.**

  이 모뎀은 우리 네트워크의 정보를 전화 시설에서 처리할 수 있는 정보로 바꾸며, 그 반대도 마찬가지이다.

  * 모뎀과의 연결 예:
    ![모뎀과의 연결](https://mdn.mozillademos.org/files/8451/internet-schema-6.png)



* 모뎀과의 연결의 다음 단계는, 우리의 네트워크에서 도달하려는 네트워크로 메세지를 보내는 것이다.
  그러기 위해서는 네트워크를 인**터넷 서비스 제공업체(Internet Service Provider, ISP)**에 연결한다.

  > ISP는 모두 함께 연결되는 몇몇 특수한 라우터를 관리 및, 다른 ISP의 라우터에도 액세스 할 수 있는 회사. 

* 우리 네트워크의 메세지는 ISP네트워크의 네트워크를 통해 대상 네트워크로 전달 된다.

  * 전체 네트워크 인프라:
    ![네트워크 인프라](https://mdn.mozillademos.org/files/8453/internet-schema-7.png)



* > 



#### 인터넷과 웹

* 웹 브라우저를 사용하여 웹을 탐색할 때 일반적으로 도메인이름을 사용하여 웹사이트에 접속한다.
  인터넷과 웹이 같은 것을 의미하는 것 처럼 보일 수 있으나, 그렇지 않다.

* 인터넷: 수십억 대의 컴퓨터를 모두 연결하는 기술 인프라.
  웹: 위에서 연결되어있는 컴퓨터들 중, 일부가 '웹 서버'로서 웹 브라우저가 이해할 수 있는 서비스를 제공하는것.

  ##### 인터넷은 인프라이며, 웹은 그 인프라 기반 위에 구축된 서비스이다.

* 웹 뿐만 아니라, 인터넷 위에 구축된 다른 서비스(이메일, IRC등)들도 존재한다.



## HTTP는 무엇일까요?

#### HTTP란?

*  HTTP(Hyper Text Transfer Protocol)는 텍스트 기반의 통신 규약으로, 인터넷에서 데이터를 주고받을 수 있는 프로토콜.
  하이퍼텍스트 문서를 교환하기 위하여 사용된 통신 규약이다.
* 웹에서만 사용하는 프로토콜로, TCP/IP기반으로 서버와 클라이언트의 요청과 응답을 전송한다.



#### HTTP의 특징

* HTTP메시지는 HTTP 서버와 HTTP 클라이언트에 의해서 해석이 된다.
* TCP/ IP를 이용하는 응용 프로토콜(application protocol)이다.
* 연결 상태를 유지하지 않는 비연결성 프로토콜.(이러한 단점을 해결하기 위해 Cookie와 Seesion 등장)
* 연결을 유지하지 않는 프로토콜이기 때문에 요청/응답(request/ response) 방식으로 동작.
* HTTP의 동작:
  ![HTTP의 동작 예제](https://t1.daumcdn.net/cfile/tistory/99971F345A93FB6D39)
  * 클라이언트(Client, 사용자): 브라우저를 통해 어떠한 서비스 URL을 통하거나, 다른 것을 통해 서버에게 요청(request) 함.
    서버(Server): 클라이언트가 보낸 요청사항에 맞는 결과를 찾아서, 클라이언트에게 응답(response)함. 
* 예로, 클라이언트 프로그램에서 사용자가 회원 가입 시도 시, 서버로 회원 정보를 보내게 되고
  서버는 회원 정보를 저장한다.
  1. Client -(회원 가입 요청 / request)-> Server
  2. Server -(가입 정보 저장/data save)-> (회원 가입 완료 페이지 전송/response) -> Client



* HTML 문서만이 HTTP 통신을 위한 유일한 정보 문서는 아니며,
  Plain text로 부터 JSON 데이터 및 XML과 같은 형태의 정보도 주고 받을 수 있다.



### HTTP 메서드

#### Request(요청)

* Request Method :
  * GET: 자료를 요청할 때 사용
  * POST: 자료의 생성을 요청할 때 사용
  * PUT: 자료의 수정을 요청할 때 사용
  * DELETE: 자료의 삭제를 요청할 때 사용



#### Response(응답)

* 상태코드:
  상태 코드는 모두 숫자 세자리로 이루어져 있으며, 굉장히 많은 종류가 있다.
  크게 다섯 가지 부류로 나눌 수 있다.
  * 1XX(조건부 응답): 요청을 받았으며 작업을 계속한다.
  * 2XX(성공): 클라이언트가 요청한 동작을 수신하여 이해했고, 승낙했으며, 성공적으로 처리했다.
  * 3XX(리다이렉션 완료): 클라이언트는 요청을 마치기 위해 추가동작을 취해야한다. 
  * 4XX(요청 오류): 클라이언트에 오류가 있음을 나타낸다.
  * 5XX(서버 오류): 서버가 유효한 요청을 명백하게 수행하지 못했음을 나타낸다.



#### 메세지 구조

* 시작줄/ 헤더/ 바디로 나눌 수 있다.
  * 시작줄: 요청내용
    * Request 시, 메서드와 요청 URL, HTTP version | ex) GET /image/logo.gif HTTP/1.1
    * Response 시, HTTP version, 상태코드 및 사유 구절 | ex) HTTP/1.1 200 OK
  * 헤더:
    * 요청과 응답 메세지에 대한 추가적인 정보를 담고있다.
    * Key/Value 형식으로 나타냄 | ex) Accept-Language: en / Content-Type: text/html
  * 바디:
    * 전송하고 싶은 실질적인 데이터를 나타낸다.
    * 헤더를 마치고 \n 후에 나타난다.

## 브라우저와 동작 원리

#### 브라우저의 주요 기능

* 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시한다.
  그 자원들은 주로 HTML 문서지만, PDF형식이거나 다른 이미지 또는 다른 형태일 수 있다.
  자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해짐.
* 브라우저는 HTML과 CSS명세에 따라 HTML 파일을 해석해서 표시하는데, 이 명세는 웹 표준화 기구인 W3C(World Wide Web Consortium)에서 정한다. 최근에는 대부분의 브라우저가 표준 명세를 따르고 있다.
* 브라우저의 사용자 인터페이스는 서로 닮아있는데, 다음과 같은 요소들이 일반적이다.
  * URI를 입력할 수 있는 주소 표시 줄
  * 이전 버튼과 다음 버튼
  * 북마크
  * 새로 고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지 버튼
  * 홈 버튼
* 브라우저의 사용자 인터페이스는 표준 명세가 없음에도 불구하고 수 년간 서로의 장점을 모방하면서 현재에 이르게 되었다.



#### 브라우저의 기본 구조

1. 사용자 인터페이스 :
   주소 표시줄, 이전/다음 버튼, 북마크 메뉴등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.

2. 브라우저 엔진 :
   사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.

3. 렌더링 엔진 :
   요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS파싱하여 화면에 표시한다.

4. 통신 :
   HTTP 요청과 같은 네트워크를 호출에 사용된다. 플랫폼 독립적인 인터페이스 이고, 각 플랫폼 하부에서 실행된다.

5. UI 백엔드 :
   콤보 박스와 창 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용.

6. 자바스크립트 해석기 :
   자바스크립트 코드를 해석하고 실행.

7. 자료 저장소 :
   자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다.
   HTML5 명세에는 브라우저가 지원하는 '웹 데이터 베이스'가 정의되어 있다.


   ![브라우저의 기본 구조](https://d2.naver.com/content/images/2015/06/helloworld-59361-1.png)



#### 렌더링 엔진

* 요청받은 내용을 브라우저 화면에 표시하는 일을 담당하고 있다.

* 표시 할 수 있는 것: HTML , XML 문서와 이미지.
  브라우저 내의 확장 기능을 이용한다면, PDF와 같은 다른 유형도 표시할 수 있다.

* 종류:

  * 게코(Gecko) 엔진 : 모질라에서 직접 만들었다. 파이어폭스가 사용 중인 엔진.
    * 동작과정:
      ![게코엔진 동작과정](https://d2.naver.com/content/images/2015/06/helloworld-59361-4.png)
  * 웹킷(Webkut) 엔진: 최초 리눅스 플랫폼에서 동작하기 위해 제작되었다. 사파리, 크롬이 사용중인 엔진.
    애플이 맥과 윈도우즈에서 사파리 브라우저를 지원하기 위해 수정을 가했다.
    * 동작과정:
      ![웹킷 동작과정](https://d2.naver.com/content/images/2015/06/helloworld-59361-3.png)

* 동작과정:
  렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작한다. (문서의 내용은 8KB 단위로 전송됨.)

  기본 과정:
  ![렌더링 엔진 기본 과정](https://d2.naver.com/content/images/2015/06/helloworld-59361-2.png)

  

  1. HTML 문서를 파싱
  2. 브라우저 화면에 렌더링 하기 위해 다루기 쉬운 구조로 바꿈.
  3. css 파일 파싱
  4. 렌더트리 구축
  5. 렌더트리 배치
  6. 렌더트리 그리기

  * 스타일 정보와 HTML 표시 규칙은 렌더 트리라고 부르는 또 다른 트리를 생성.
    * 렌더 트리는 색상 또는 면적과 같은 시각적 속성이 있는 사각형을 포함하고있는데, 정해진 순서대로 화면에 표시.
      생성이 끝나면 배치를 시작한다.
  * 화면에 표시하기 위한 위치, 크기, 그리기 순서 저장을 위한 별도의 트리 구조(렌더트리)가 필요하다.
  * 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데, 모든 HTML을 파싱할 때 까지 기다리지 않고 배치와 그리기 과정을 시작한다.
  * 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 화면에 표시하는 것.

## DNS와 작동 원리

#### DNS란?

* 도메인 네임 시스템(Domain Name System, DNS)
* 호스트의 도메인네임(www.example.com)을 네트워크주소(192.168.1.0)로 변환하거나, 그 반대의 역할을 수행하는 분산형 데이터베이스 시스템.
  * 이름과 숫자간의 매핑을 관리하여, 마치 전화번호부와 같은 기능.
  * 사용자가 도메인 이름을 브라우저에 입력 할 시, 사용자를 어떤 서버에 연결할 것인지 제어한다. 이러한 요청을 **쿼리**라고 함.



#### DNS 서비스 유형

* 신뢰할 수 있는 DNS : 
  * 개발자가 퍼블릭 DNS 이름을 관리하는 데 사용하는 업데이트 매커니즘을 제공 한다. 
    이를 통해 DNS 쿼리에 응답하여, 도메인 이름을 IP 주소로 변환한다.
  * 신뢰할 수 있는 DNS는 도메인에 대해 최종 권한이 있으며, 재귀적 DNS 서버에 IP 주소 정보가 담긴 답을 제공할 책임이 있다.
* 재귀적 DNS:
  * 대개 신뢰할 수 있는 DNS 서비스에 직접 쿼리를 수행하지 않고, 해석기 또는 재귀적 DNS 서비스라고 알려진 다른 DNS 서버에 연결하는 것이 일반적.
  * DNS레코드를 소유하고 있지 않지만, 사용자를 대신해 DNS정보를 가져올 수 있는 중간자 역할을 함.
  * 일정 기간 동안 캐시된, 혹은 저장된 DNS 레퍼런스를 가지고있는 경우, 소스 또는 IP 정보를 제공하여 DNS쿼리에 답한다.
  * 아무것도 가지고 있지 않는다면, 해당 정보를 찾기 위해 쿼리를 하나 이상 신뢰할 수 있는 DNS 서버에 전달.



#### DNS 동작 원리

1. 사용자가 PC 브라우저에 www.naver.com과 같은 주소를 입력한다.
2. PC는 미리 설정되어 있는 DNS(단말에 설정된 DNS: Local DNS)에 "www.naver.com"에 대한 IP주소를 요청.
3. Local DNS에 "www.naver.com"에 대한 IP 주소의 유무에 따라 결과가 달라지는데,
   * IP 주소가 있을 경우: Local DNS가 PC에 IP주소를 전달.
   * IP 주소가 없을 경우: "www.naver.com" IP 주소를 찾아내기 위해 다른 DNS 서버들과 통신(DNS 메세지) 시작.
4. Root DNS 서버에 가장 먼저 "www.naver.com" IP주소를 요청.
   이를 위해 각 Local DNS 서버에는 Root DNS 서버의 정보(IP 주소)가 미리 설정되어 있어야 한다.
   * Root DNS란? : 
     전 세계에 13대가 구축되어 있으며, 미국에 10대, 일본/네덜란드/ 노르웨이에 각 1대씩 구축되어있다.
     한국에서는 Root DNS 서버에 대한 미러 서버를 3대 운용 중이다.
5. Root DNS 서버는 "www.naver.com" IP 주소를 저장하고 있지 않기 때문에, "com 도메인"을 관리하는 TLD(Top-Level Domain) 서버의 정보를 전달한다.
6. Local DNS 서버는, TLD 서버에 IP 주소를 재 요청.
7. com 도메인을 관리하는 DNS 서버에도 해당 IP 주소가 존재하지 않기 때문에, "naver.com 도메인"을 관리하는 DNS 서버의 정보를 전달한다.
8. Local DNS 서버는, naver.com 도메인을 관리하는 DNS 서버에 IP 주소를 재 요청.
9. naver.com 도메인을 관리하는 DNS 서버는 해당 IP 주소를 저장하고 있기 때문에, IP 주소 (222.122.195.6)를 전달.
10. 이를 수신한 LocalDNS 서버가 IP 주소를 캐싱 후, 단말 PC에 정보를 전달.



* Local DNS 서버가 여러 DNS 서버를 차례대로 거쳐, 답을 알아내는 과정을 Recursive Query라 한다.

  ![DNS 동작 원리](https://t1.daumcdn.net/cfile/tistory/99C16C455BDFBB2A23)

## 도메인 네임은 무엇일까요?

* 도메인 네임(Domain name)은, 넓은 의미로는 네트워크상에서 컴퓨터를 식별하는 호스트명을 가리키며,
  좁은 의미로는 도메인 레지스트리에게서 등록된 이름을 의미한다.



#### 컴퓨터 찾기

* 컴퓨터에 메세지를 보내기 위해서는, 메세지를 받을 특정 컴퓨터를 지정해야하는데,
  모든 사람의 집에는 집주소가 있듯, 네트워크에 연결된 모든 컴퓨터에는 IP주소(Internet Protocol)라는 고유한 주소가 있다.

  * IP 주소는, 점으로 구분 된 네 개의 숫자로 구성된 주소. ex) 192.168.2.10

* IP주소를 입력하게 되면, 다른 컴퓨터를 찾아가는 데 문제가 없지만 이러한 주소를 기억하는 것은 어려운 일이다.
  때문에, '도메인 네임'이라고 하는 IP주소의 이름을 지정할 수 있다.(쉽고 외우기 간편하도록 영문을 사용한 주소체계이다.)
  ex) google의 본래 IP 주소: 173.194.121.32
         google의 도메인 주소: http://www.google.com

  > 친구의 전화번호에 전화를 걸기 위해서 번호를 외우는 것보다, 핸드폰의 연락처 앱의 검색창에 친구의 이름을 검색하여 전화를 거는 것처럼
  > 보다 간편하게 사용자들이 인터넷을 사용할 수 있도록 만들어진 것.



#### 도메인 네임의 구성 요소

* 도메인 네임은 알파벳과 숫자, '-'(dash, hiphen)으로 구성 되어있으며, 점(dot)으로 구분하여 계층적으로 이루어져 있다.

* 컴퓨터의 이름과 최상위 도메인으로 구성 되어있고, 오른쪽에서부터 1단계, 2단계 3단계 도메인이라고 불리며 오른쪽에서 왼쪽으로 갈수록 도메인의 범위가 작아진다.

  > ex:
  > 다음 : daum.co.kr
  > 1단계 -> 국가 도메인 (kr)
  > 2단계 -> 도메인의 성격(국가형태의 최상위 도메인을 의미한다. 해당 도메인이 사업체의 도메인이라는 것을 알려줌.)
  >
  > 3단계 -> 도메인 네임을 등록하는 사람이 설정한 이름. (컴퓨터의 이름)
  >
  > > 여기서 www가 붙어있는 주소의 경우, 도메인 네임에 포함되지 않는 '호스트명'이라고 한다.



#### 최상위 도메인

* 도메인의 마지막 점(.) 이후의 문구가 이에 해당된다.

* 도메인 네임은 그 최상위 도메인이 암시하는 관리 기관 및 등록 요건에 따라 다음과 같이 나뉜다.
  * 일반 최상위 도메인(gTLD) :
    ICANN이 관리하는 도메인. .com, .org, .net 등이 포함된다.
    대부분 국가와 관계 없이 등록할 수 있기 때문에 국제 도메인이라고도 불리기도 하지만, 역사적인 이유로 .mil , .gov는 미국 국가 기관의 제한을 받음.
  * 국가 코드 최상위 도메인(ccTLD) :
    ISO 3166-1에 의하여 이름이 결정되고, 각국의 NIC에서 관리하는 국가별 도메인.
    .kr, .jp, .hk 등이 이에 해당된다.

## 호스팅은 무엇일까요?

#### 호스팅이란?

* 정보의 집약체인 서버의 전체, 혹은 일부를 이용할 수 있도록 임대해 주는 서비스.
* 서버를 관리하기 위해서는 24시간 동안 안정적인 전기 공급과, 빠르고 안정적인 인터넷 회선, 철저한 보안 시스템을 갖추고 있어야 하기 때문에
  개인이 서버를 관리하는 것 보다, 전문 업체의 호스팅 서버를 사용하는 것이 일반적.



#### 호스팅의 종류

* 웹 호스팅
  * 여러 고객이 하나의 서버를 함께 사용하는 형태.
    * 장점: 하나의 서버를 나누어 쓰기 때문에 저렴한 비용과 호스팅 업체의 통합관리를 받아 편리하다.
    * 단점: 사용할 수 있는 하드웨어가 제한적임
* 서버 호스팅
  * 고객이 단독 서버를 사용하는 형태.
    * 장점: 넓은 하드웨어 공간을 사용 할 수 있고, 서버 운영/관리에 대한 직접적인 권한을 가짐.
      빠른 데이터 전송 속도 이용 가능.
    * 단점: 높은 비용.
  * 대기업이나 대형 포탈 혹은 대형 오픈마켓과 같이, 많은 데이터를 사용하는 기업들이 사용하기 좋다.
* 클라우드 서버
  * 서버 호스팅을 가상화 한 것. 가상 서버를 단독으로 사용할 수 있는 형태.
    * 장점: 고객이 필요할 때마다 서버 자원을 늘리거나 축소하여 유연하게 서버 이용 가능.
    * 단점: 하나의 가상 서버에 문제가 생기면, 연결된 다른 가상 서버에도 문제가 생길 수 있음.

