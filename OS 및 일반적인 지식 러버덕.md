# OS및 일반적인 지식

## OS(Operating System : 운영체제)

### 1. 운영체제(OS)란?

* 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하게 사용할 수 있도록 환경을 제공 하는 프로그램의 모임.
* 컴퓨터와 하드웨어(CPU,I/O) 위에 설치 되어, 사용자 및 다른 소프트 웨어와 하드웨어를 연결하는 중개자 역할을 한다.
  이 때, 자원의 공유 및 분배를 위한 policy를 제공한다.
* Abstraction : 사용자를 위하여 제공되는 것.
  * 프로그램(program): 컴퓨터를 실행시키기 위해 순차적으로 작성된 명령어 모음. 
  컴퓨터 시스템의 disk와 같은 scondary storage에 바이너리 형태로 저장된다.
  * 프로세스(process): 실행되고 있는 프로그램의 추상화.
    
    > 추상화? (OS Abstraction)
    > 가상 메모리를 사용하여 메모리를 늘린것과 같이 사용하거나, 멀티태스킹 같은 역할을 하는 것.
    >
    > 추상화된 기능들을 쉽게 사용할 수 있도록 시스템호출(System call)을 제공.
  * 주소공간(Address Space): 프로세스가 차지하는 메모리 공간. 서로의 주소공간을 침범할 수 없다.
  * 파일(File): 프로세스에서 읽고 쓸 수 있는 Persistent storage.
  * 포트(port): 컴퓨터간에 메세지를 주고받는 communication end point. 여러가지 프로세스가 네트워크 내에서 섞이지 않게 만들어줌.
  * 커널(Kernel): 운영체제의 핵심. 시스템의 모든것을 통제 함.
    > 커널의 역할:
    > 보안, 자원관리, 추상화.
    

![image](https://user-images.githubusercontent.com/69128652/97526395-59881980-19ec-11eb-9f82-71d59de6d32d.png)

#### 운영체제의 역할

  1. 프로그램들이 자원을 필요로 할 때, 자원을 할당함. 한정적인 자원을 효율적으로 관리.
  2. 자원을 할당받은 프로그램들이 서로의 영역 또는 자원을 침범을 하지않게 하고, 컴퓨터의 부정사용을 방지하는 **제어프로그램**의 역할을 함.

#### 운영체제의 구조

* 멀티 프로그래밍
  * 메모리에 여러 Job(프로그램, 프로세스 통칭)을 저장해두고, 하나의 Job실행 도중 I/O작업 등이 발생하여 유휴시간이 생겼을 때 다른 Job을 시작하여 CPU의 효율성을 증가시킨다. </br>여러개의 작업(Job)을 메모리에 동시에 유지시킴.
  * 하지만, 사용자가 실행중인 작업에 관여할 수 없어, 우선순위가 높은 작업을 먼저 처리해야하는 경우 문제가 발생할 수 있다.
  (이 때, Job Scheduling으로도 해결 할 수 없다.)
* 타임 셰어링
  * 멀티 프로그래밍에서 확장된 개념. 멀티 태스킹이라고도 한다.
  * CPU가 스케쥴링을 통해 작업들을 빠르게 Switching하면서, 동시에 프로그래밍이 구성되는 것 처럼 느껴지게한다.
  * 메모리가 모자라는 경우, 스와핑을 통해 프로세스를 가상메모리에 저장.
  
  
### 2. 운영체제의 작동(Operating System Operations)
* 현대의 운영체제는 인터럽트를 기반으로 한다.
* 실행할 프로세스가 없다면 운영체제도 작동하지 않고, 인터럽트나 트랩이 발생하면서 이벤트 발생.
  * 인터럽트(Inturrupt): CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요한 경우, </br> CPU에게 문제를 알려, 처리할 수 있도록 하는 것.
    * 인터럽트의 대응이 끝난 후, 그 다음 명령어를 수행하거나 대기 상태로 돌입하기 위해, OS는 명령어의 주소를 저장한다.
    * 인터럽트의 종류:
    * 외부 인터럽트: 키보드,마우스 등과 같이 외부에 기반하여 발생하는 인터럽트
    *  내부 인터럽트: 프로그램 안에서 실행되는 인터럽트.
    
  
 * 하드웨어 보안
  * 듀얼모드:
    * 운영체제가 유저모드와 커널모드로 나누어 동작하는 것.
    > 유저모드:
    >
    > * 커널 모드에 비해 낮은 권한의 실행모드.
    > *  Privilege 명령어 실행 불가능.
    > *  어플리케이션이 실행되며, 시스템에 영향을 주는 연산을 사용할 수 없어 하드웨어 보안을 유지시킨다.
    > *  유저 어플리케이션이 커널모드에서만 제공되는 인스트럭션을 사용하려는 경우, 유저모드 프로세스 내에서 비트(Bit)를 변경하는 시스템 콜을 실행한다.
    
    > 커널모드:
    >
    > * 모든 권한을 가진 실행모드.
    > *  운영체제가 실행되는 모드.
    > *  Privilege명령어 실행 및 레지스터 접근 가능.
    
    * 유저 어플리케이션이 커널 모드에서만 제공되는 인스트럭션을 사용하려는 경우, 커널에 접근하게 해주는 시스템 콜(System call)을 실행.
      ![image](https://user-images.githubusercontent.com/69128652/97526636-e7fc9b00-19ec-11eb-8e61-34ccead97275.png)



#### 커널?



## 스케줄링

* 다중 프로그래밍을 가능하게 하는 운영체제의 동작기법.
* 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에 할당하는 작업 이다.
* 프로세스는 여러종류의 스케쥴링 과정을 거치는데, 이 때의 스케줄링의 종류로는 장기 스케줄링, 중기 스케줄링, 단기 스케줄링이 있다.
  * 장기 스케줄링:
    * 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할것인가를 결정하여 준비상태 큐로 보냄.
    * 상위 스케줄링이라고도 한다.
  * 중기 스케줄링:
    * 어떤 프로세스들이 CPU를 할당 받을 것인지 결정.
    * 할당을 받으려는 프로세스가 많을 경우, 일시보류 시킨 후 활성화 하여, 일시적으로 부하를 조절한다.
  * 단기 스케줄링:
    * 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업.
    * 프로세서 스케줄링, 하위 스케줄링이라고도 한다.

### 1. 스케줄링 방식

크게 선점형(Preemptive) 스케줄링, 비선점형(Non-Preemptive) 스케줄링 으로 나뉜다.

* 선점형(Preemptive) 스케줄링
  * 프로세스가 CPU를 할당받아 실행중이더라도, 다른 프로세스가 CPU를 강제로 빼앗을 수 있는 방식.
  * 처리시간이 긴 프로세스가 CPU 사용 독점을 맏을 수 있어 효율적인 운영이 가능하지만, 잦은 스위칭으로 오버에드가 많이 발생한다.
* 비선점형(Non-Preemptive) 스케줄링
  * 프로세스가 CPU를 점유하고 있을 때, 다른 프로세스가 CPU를 강제로 빼앗을 수 없는 방식.
  * 필요한 스위칭만 일어나, 오버헤드가 비교적 적게 일어나지만, 프로세스 배치에 따라 효율성 차이가 많이 난다.



### 2. 스케줄링 종류

* First-Come, First-Served(FCFS)

  * 비선점형 스케줄링. 먼저 온 프로세스가 먼저 CPU를 점유하는 방식.
  * 프로세스가 차례대로 P1, P2, P3 순서대로 들어온 것을 Convoy Effect라고 한다.
    ![image](https://user-images.githubusercontent.com/69128652/97556719-2ca02a80-1a1d-11eb-8f88-b51bbf364050.png)

* Shortest-Job-First(SJF)

  * 선점형과 비선점형 방식 모두 가능하며, 가장 짧게 수행되는 프로세스가 가장 먼저 수행되는 방식.
  * 현실적인 컴퓨터 환경에서는 프로세스의 CPU점유 시간을 알 수 없을 뿐더러, 많은 변수가 존재하기 때문에 비현실적이다.
    CPU점유 시간을 알려면 실제로 수행하여 측정하는 수밖에 없어, 큰 오버헤드를 발생시킨다.
  * 위와 같은 이유로 잘 사용되지 않는다.
    ![image](https://user-images.githubusercontent.com/69128652/97556736-31fd7500-1a1d-11eb-9119-910d8d683e9a.png)

* Priority

  * 선점형과 비선점형 방식 모두 가능하며, 우선 순위가 높은 프로세스 먼저 선택되는 스케줄링 알고리즘.

  * 우선순위를 정하는 방법에, 크게 내부적인 요소와 외부적인 요소로 나뉜다.

    * Internal : Time limit, Memory Requirement I/O to CPU burst(I/O 작업은 길고, CPU 작업은 짧은 프로세스 순.)
    * External : Amount of funds beging paid, Political Factors등

  * 프로세스가 CPU 점유를 오랫동안 하지 못하는 ,Starvation(기아) 같은 현상이 발생 한다.

    이를 해결하는 방법으로 Aging(우선 순위가 낮은 프로세스가 일정시간이 지나면, 우선순위를 일정량 높여주는 방식.)이 있다.
    ![image](https://user-images.githubusercontent.com/69128652/97556752-3590fc00-1a1d-11eb-8174-6cbd1e44f275.png)

* Round-Robin(RR)

  * 기본적으로 선점형 스케줄링.
    일정시간(Time Quantum, Time Slice)을 정하여 각각의 프로세스가 이 시간 동안만 수행하고 대기 상태로 돌아가는 방식.

  * Time Quantum의 크기에 따라 달라져, 매우 의존적이다.

    크기가 크다면, FCFS와 동일하게 작동하지만, 크기가 작다면 스위칭 오버헤드가 매우 커서 비효율적이다.
    ![image](https://user-images.githubusercontent.com/69128652/97556761-388bec80-1a1d-11eb-88a4-6eb56f726882.png)

## 터미널
### 1. 터미널이란?
* 키보드와 모니터 등으로 이루어진 단말기. 컴퓨터와 소통하기 위해 키보드를 사용하는 것.
* 주로 명령줄 모드(CLI,Command Line Interface)를 나타내는 말이다.</br>
텍스트 기반 명령을 입력하고 실행할 수 있는 인터페이스.

* 기술적으로는 다른 의미이지만, Terminal, Console, Shell, Command Line으로 불리기도 한다.
  * 콘솔(console)
  * 커멘드 라인(명령줄, command Line): 명령을 입력하는 모든 것.
  * 쉘(Shell): 명령 실행을 위한 응용 프로그램. 터미널로 쉘을 실행시킨다.
  
#### 사용하는 이유
* 일부의 경우, 그래픽 응용 프로그램 및 메뉴보다 터미널을 사용하여 작업을 완료하는 것이 빠르기 때문.
* 더 많은 명령과 스크립트에 액세스 할 수 있기 때문.
  
### 2. CLI/ TUI/ GUI
> Shell을 기본적으로 사용하고 있다.
> Shell: 사용자가 명령을 내리면, 그 명령을 해석하여 커널에 전달해주는 인터페이스 역할. 크게 CLI와 GUI로 나뉜다.
* CLI(Command Line Interface)
  * 가상 터미널을 통해 사용자와 컴퓨터가 문자열 형태로 입출력을 주고받는 형태의 인터페이스. 명령줄 인터페이스라고도 한다.
  * 서버 관리 및 프로그래밍 분야에서 사용되며, GUI에 비해 자원을 적게 소모하고 안정적이다.
  * 사용 예: 도스, 명령 프롬프트, 유닉스 쉘 등.
  
 * TUI(Text-based User Interface)
  * 터미널 사용자 인터페이스라고도 한다.
  * 텍스트 기반 사용자 인터페이스로, 화면에 글자만을 이용해 레이아웃 표현도 가능하다.
  * GUI와 같이 화면 전반을 사용하며, 마우스와 다른 입력을 할 수 있다.
  
 * GUI(Graphical User Interface)
  * 사용자의 편의성을 위해 입출력 등의 기능을 아이콘이나 그래픽으로 표시한다.
  * CUI보다 직관적으로 조작할 수 있다.
  * 컴퓨터 뿐만 아니라, MP3플레이어 등 수많은 휴대용 모바일 장치에도 사용된다.

### 3. 터미널 환경
* 대부분의 백엔드 시스템이 리눅스 기반의 서버에서 운영되기 때문에, 텍스트 터미널을 통해 작업하는 경우가 많다.
* Windows 는 CMD, Mac OS 는 Terminal이 CLI제공 응용프로그램이다.</br> **입력 과 출력**으로 구성된다.
  * Command Prompt(명령 프롬프트) : </br>
    windows: '>'
    </br> Mac OS, Linux: '$'
    * 사용자는 이 부분에 명령어를 입력하여 사용한다.
   * 명령 프롬프트를 통해 특정 명령어를 입력 받고, 셀프로그램이 해당 명령어를 해석하여 적절한 내용을 터미널에 출력한다.
### 4. 자주 사용 되는 명령어
* 운영체제와 상관 없이 공통적으로 자주 사용되는 명령어.
1. ls, dir: 지정한 파일 또는 디렉토리를 표시한다.
    </br> ls: Mac OS, Linux 등 bash프로그램을 사용하는 터미널의 경우.
  ``` $ ls
$ ls -a # 숨김파일까지 확인 가능
$ ls -la # 상세보기 la 만 사용 가능
  ```
  </br> dir: Windows, DOS기반 명령 프롬프트를 사용하는 커맨드의 경우.
  ```
  > dir
  ```
2. cd: change directory의 약자. 다른 디렉토리로 이동.
```
$ cd <현재 디렉토리의 폴더 이름>  // 폴더로 이동
$ cd <디렉토리>               // 특정 디렉토리로 이동
$ cd ../                    // 상위 디렉토리로 이동
$ cd ~                      // 루트 디렉토리로 이동
```
3. sudo: superuser do. 현재 계정(일반 사용자)에서 root 권한을 이용하여 명령어 실행.
```
// sudo 다음에 실행할 명령을 입렵하면 root 권한으로 명령어를 실행

$ sudo apt-get update
```

4. pwd: print working directory의 약자. 현재 작업중인 디렉토리의 절대 경로를 출력한다.
```
[root@localhost bin]# pwd
/usr/bin
[root@localhost bin]#
```

5. mkdir: make directory의 약자. 새로운 디렉토리 생성.
```
$ mkdir [옵션] 생성할 디렉토리 이름

$ mkdir linux // 현재 경로에 linux 라는 디렉토리 생성
$ mkdir -p girls/tiffiny // 상위 디렉토리 경로를 포함하는 디렉토리 생성
```

6. rm: remove의 약자. 하나 이상의 파일을 삭제할 때 사용. 옵션값을 입력하면 디렉토리 삭제도 가능하다.
```
$ rm [옵션] 파일명/디렉토리명

$ rm -f test.txt // test.txt 라는 파일을 삭제 여부 묻지 않고 강제 삭제
```


## 메모리
### 1. 메모리의 종류
* RAM(Random Access Memory):
  * 전원 공급을 끊으면 기록한 데이터가 소실되는 휘발성 메모리. 프로그램이나 데이터를 일시적으로 저장하는 용도로 사용.
  * 크게 SRAM(Static RAM) 과 DRAM(Dynamic RAM)으로 분류 된다.
    * SRAM:
    </br> 제어가 쉽고 읽기/쓰기 동작이 고속이다.
    </br> 셀 면적이 크기 때문에 대용량화에 적합하지 않고, 가격이 비싸다.
    * DRAM:
    * 정기적으로 리플레시 신호를 주지않으면 데이터가 소실된다. 제어가 복잡함.
    * 셀 면적이 작기 때문에 대용량화에 적합하다. 가격이 SRAM보다 저렴.
    *  대표적으로 SDRAM이 존재한다.
  
* ROM(Read Only Memory):
  * 읽기 전용 메모리. 데이터가 소실되지 않는 비휘발성 메모리. 다시 작성할 필요가 없는 프로그램이나, 데이터 저장에 사용.
  * 크게 mask ROM 과 PROM(Programmable ROM)으로 나뉜다.
    * Mask ROM:
    
      * 일반적인 ROM
      * 제작시 데이터를 저장해두고, 이후 지우거나 덮어씌우는 것이 불가능.
    
    * PROM:
    
    * 사용자가 데이터를 1회 기록할 수 있는 ROM.
      
      * OTP,EPROM,EEPROM등으로 나뉜다.
        * EPROM:
      
           저장되어 있는 데이터를 쓰고 지울 수 있는 ROM. 데이터를 지우는 방법에 따라 EEPROM, UVEPROM 으로 나뉜다.
  
* Flash Memory:
  * EPROM의 한 종류. 기존 PROM 종류보다 더 빠르게 기록/ 삭제가 가능한 메모리.
  * 구조에 따라서 NOR과 NAND형 메모리로 분류 된다.
  
### 2. 가상 메모리
  * 메모리를 관리하는 방법 중 하나. 각 프로그램에 실제 메모리 주소가 아닌, 가상의 메모리 주소를 주는 방식.
      이 때 디스크 상에 존재하는 파일을 Paging file 이라고 한다.
  * 멀티태스킹 운영체제에서 흔히 사용되며, 실제 주기억장치(RAM)보다 큰 메모리 영역을 제공하는 방식 사용.
  * 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽거나 쓸 때에만 물리주소로 바꿔준다.
    * virtual address (가상주소) : 프로세스가 참조하는 주소
    * physical address (물리주소) : 실제 메모리 주소
    
   * MMU (Memory Management Unit) : 
       cpu에서 코드 실행시, 가상 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치.
#### 3. 매핑
* MMU하드웨어에 의해 지원되는 기능.가상메모리와 실제 메모리 사이의 중계를 맡고 있다.
* Paging과 Segmentation, 이 두가지 방식을 혼합한 방법. 총 3가지로 분류된다.

* 페이징(Paging) 기법
  * 컴퓨터가 메인 메모리에서 사용하기 위해 데이터를 저장하고 검색하는 메모리 관리 기법.
  * 가상 메모리 상의 주소 공간을 일정한 크기로 분할한다. 주소 공간은 페이지 단위로 나뉘어져 있으며, 실제 기억 공간은 페이지 크기와 같은 프레임으로 나누어 사용함.
    * Frame: 물리 메모리를 일정한 크기로 나눈 블록
    * Page: 가상 메모리를 일정한 크기로 나눈 블록.
  * 페이징 기법 사용시, 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화(External fragmentation)를 해결 할 수 있다.
  
* 세그멘테이션(Segmentation)
 * 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할하고 메모리를 할당하여 주소를 변환한다.
 * 각각의 세그먼트들은 연속적인 공간에 저장되어있으며, 세그먼트들의 크기가 서로 다르기 때문에, 메모리를 페이징 기법처럼 미리 분할해 둘 수 없다.
 * mapping을 위해 세그먼트 테이블이 필요.
 * 하나의 세그먼트 단위로 메모리를 통제할 수 있어, 내부 단편화가 발생하지 않지만,
 서로 다른 크기의 세그먼트들을 동적 관리 하므로, 외부 단편화가 생길 수 있다.

### 4. 메모리계층 구조
* 레지스터, 캐시: CPU내부에 존재. 빠르게 접근할 수있다.
* 메모리: CPU외부에 존재. 레지스터,캐시보다 느리게 접근.
* 하드디스크: CPU가 직접 접근할 방법 없음. 아주 느린 접근밖에 불가능 하다.
![](https://user-images.githubusercontent.com/69128652/96000303-b5419700-0e71-11eb-82c9-dd2b3fdac552.png)

* 메모리를 필요(대부분의 경우, CPU가 메모리에 빨리 접근하기 위함)에 따라 여러가지 종류로 나누어 둠(계층화)을 의미한다.

* 메모리 계층 구조의 필요성:
  * 자주 쓰이는 데이터는 계속 쓰인다. (참조의 지역성): 자주 쓰이는 데이터는 전체 데이터의 일부이기 때문에, 상위 메모리의 용량이 하위 메모리의 용량보다 작아도 된다.
  * 디코딩(명령 해독 단계) 속도: 여러 개의 메모리를 사용 할 시, CPU는 자신이 원하는 메모리에 접근 해야한다. 이 과정에서 컨트롤 신호를 해석해야하는데, 메모리가 클수록 해당 비용이 증가한다.
  * 경제성: 상위 계층의 메모리일 수록 가격이 올라간다.

## 프로세스
* 컴퓨터에서 연속적으로 실행 중인 컴퓨터 프로그램. 운영체제 내에서 프로세스 관리가 중요하다.
* job,task 등과 같은 이름으로 불리기도 한다.
* 여러개의 프로세서를 사용하는 것을 멀티 프로세싱, 같은 시간에 여러개의 프로그램을 띄우는 시분할 방식을 멀티태스킹 이라고 한다.

### 1. 프로세스 상태
* 생성(create): 프로세스가 생성되는 중이다.
* 실행(running): 프로세스가 CPU를 차지하여 명령어들이 실행되고 있다.
* 준비(ready): 프로세스가 CPU를 사용하고 있지는 않지만, 언제든지 사용할 수 있는 상태.일반적으로 준비상태의 프로세스 중 우선순위가 높은 프로세스가 CPU를 할당받음.
* 대기(waiting): 보류(block)라고 부르기도 한다. 프로세스가 입출력 완료, 시그널 수신 등 어떤 사건을 기다리고 있는 상태.
* 종료(terminated): 프로세스의 실행이 종료 된 상태.

### 2. 프로세스의 상태전이
1. 하나의 프로그램 실행 시, 그 프로그램에 대응되는 프로세스가 생성되어 준비리스트의 끝에 들어간다.
2. 준비 리스트 상의 다른 프로세스들이 CPU를 할당받아 준비 리스트를 떠난다.
3. 점차 준비 리스트의 앞 순서로 나가게 되고, CPU를 사용할 수 있게 됨.
  * 디스패치(dispatch): 준비 리스트의 맨 앞에 있던 프로세스가 CPU를 점유하게 되는 것. ( 준비 상태-> 실행 상태)
  * 보류(block): 실행 상태의 프로세스가 허가된 시간을 다 쓰기 전에 추가적인 입출력 동작을 필요로 하는 경우, 프로세스는 CPU를 반납하고 보류상태로 넘어가게 되는 현상.
  * 깨움(wakeup): 입출력 작업 종료 등, 기다리던 사건이 일어났을 때 보류 상태에서 준비 상태로 넘어가는 과정.
  * 시간제한(timeout): 프로세스가 프로세서를 독점하지 못하기 위해 clock interrupt를 둔 것. 프로세스가 일정 시간 동안만 프로세서를 점유할 수 있도록 한다.



#### 프로세스 큐(Queue)

* 프로세스가 여러개의 작업을 진행할 때, 순서를 대기하는 곳.
* 준비 큐, 대기 큐, 실행 큐 등의 자료 구조가 있다.
* 각 큐 내부에 저장된 실제 데이터에는 각 프로세스의 PCB(프로세스 블럭: Process Control Block)가 저장되어있다.
  순서를 정해주는 알고리즘이 있는데, 이를 스케줄링이라고함.



### 3. 프로세스의 동시 실행
* 하나의 CPU(프로세서)는 한 순간에 하나의 프로세스만 실행할 수 있다.
* 운영체제가 빠르게 CPU가 실행할 프로세스를 교체하고 있기 때문에, 여러개의 프로세스가 실행 되고 있다고 느끼는 것이다.

### 4. 프로세스간 통신(IPC: Inter-Process Communication)
* 프로세스들 사이에 서로 데이터를 주고받는 행위 혹은, 그에 대한 방법이나 경로.
* 프로세스간의 통신을 위해 PIPE 같은 개념이 생성되었다.

#### PIPE

![image](https://user-images.githubusercontent.com/69128652/97531284-39118c80-19f7-11eb-95c4-1d102395eabc.png)

![image](https://user-images.githubusercontent.com/69128652/97531294-3d3daa00-19f7-11eb-8b2d-a88f4f88c5f6.png)

* 프로세스는 메모리 공간을 복제하기 때문에, 통신을 위해 메모리 공간을 할당해주어야한다. 이 때 사용되는 기술.
* 통신을 위한 메모리 공간(버퍼)을 생성하여 프로세스가 데이터를 주고받게 끔 해준다.
* 단방향 통신이라는 특성 때문에, 자원의 낭비가 심하다는 단점이 있다.
* PIPE의 종류:
  * 익명 파이프(Anonymous Pipe):
    * 외부 프로세스에서 사용할 수 없는 파이프. 프로세스가 자식 프로세스를 생성하는 경우, 파일 지정 번호를 상속받아 통신할 수 있다.
    * 사용이 제한적.
  * 네임드 파이프(Named Pipe):
    * 읽기/쓰기가 모두 가능하지만, 한번에 한 방향으로만 통신이 가능한 반이중통신.
    * 전이중통신을 읽기 위해서는 읽기 파이프, 쓰기 파이프를 각각 생성해야한다.
    * 다수의 클라이언트를 처리하기엔 비효율적이다.
    
#### Unix Domain Soket
* 소켓 함수와 기술을 그대로 사용한 것. 유닉스 서버에서 서버/클라이언트 환경을 만들 수 있다.
* 서버/클라이언트 환경을 구축하는데 용이하여, 중대형 어플리케이션에서 주로 사용.
  ![image](https://user-images.githubusercontent.com/69128652/97552865-1d6aae00-1a18-11eb-953d-60a010ddea2e.png)

#### 공유 메모리 (Shared Memory)
* OS가 제공하는 메모리를 프로세스들이 공유하는 메모리.
* 대량의 정보를 다수의 프로세스에게 배포가 가능하며, 빠르고 효율적이지만 공유 메모리 공간에 대한 접근 제어가 필요하다.
  ![image](https://user-images.githubusercontent.com/69128652/97552880-20fe3500-1a18-11eb-8f0f-3d0f00fbf7f0.png)
### 5. 프로세스와 스레드의 차이
* 프로세스: 생성되면서 메모리 공간 등을 복사하여 자원을 할당.
  * 정적인 프로그램과 달리, 프로세스는 실제 실행 중인 프로그램을 일컫기 때문에 동적이라고 표현하기도 한다.
  * 한 프로그램에서 실행되는 여러 프로세스가 동시에 존재할 수 있다.
  * Process Control Block(PCB)이라고 하는 자료구조 안에 커널 스케쥴러가 프로세스를 제어하는 데 필요한 정보들이 담겨 있다.
  
* 스레드: 메모리 공간과 자원들을 공유. 실제로 작업을 수행하는 일꾼이다.
  * 하나의 프로세스가 생성되면 다른 하나의 스레드가 같이 생성되며, 이를 메인 스레드라고 한다.
  * 여러 개의 스레드를 가질 수 있으며, 이 때의 스레드를 멀티 스레드라고 한다.

* 시스템 자원을 효율적으로 관리하기 위해, 하나의 프로세스에서 스레드로 나눠가면서 작업을 진행하게 된다.
  * 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원의 효율적인 관리가 가능.
  * 프로세스 간의 통신보다 스레드 간의 통신의 비용이 적으므로, 작업들간의 통신 부담 줄임.
   스레드 사용시, 자원의 효율성이 증가하지만, 동기화 문제에 신경써야 한다.

### 6. 멀티 프로세스와 멀티 스레드
* 멀티 프로세스(multi-process), 멀티 프로세싱
  * 여러개의 프로세서가 작업을 병렬적으로 처리.
  프로세스가 하나의 작업을 전담하는 것이 아닌, 하나의 작업을 처리할 때도 여러개의 프로세스가 협력적으로 작업을 처리한다.
  * 단일 프로세싱을 이용할 때 보다 비용을 절감하며, 
   프로세스가 작업을 나눠 실행하기 때문에 문제가 발생하여도 영향이 확산되지 않아 신뢰성이 증가한다.
  *  Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생한다.
   또한, 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching가 발생하면 캐시에 있는 모든 데이터를 모두 리셋하고 다시 캐시 정보를 불러와야 한다.
  
* 멀티 스레드(Multi-threading)
  * 하나의 프로세스를 여러 개의 실행 단위이며, 여러 개의 스레드끼리 자원을 공유하는 것.
  * 윈도우, 리눅스 등 많은 운영체제들이 멀티 프로세싱을 지원하고 있지만 멀티 스레딩을 기본으로 하고 있다.웹서버는 대표적인 멀티 스레드 응용 프로그램
  * 간단한 통신 방법으로 인한 프로그램 응답 시간 단축. 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다.
  * 하지만, 단일 프로세스의 경우 효과 기대가 어려우며 다른 프로세스의 스레드 제어가 불가능 하다.
   또한, 하나의 스레드에 문제 발생 시 전체 프로세스가 영향을 받거나, 동기화 문제로 자원 공유의 문제가 발생할 수 있다.
  
 #### 멀티 프로세스로 할 수 있는 작업을 멀티 스레드로 하는 이유.
 * 자원의 효율성 증대
  * 프로세스를 생성하여 자원을 할당하는 시스템 호출(System Call)이 줄어들어 자원을 효율적 관리 가능.
  * 스레드는 프로세스 내의 메모리를 공유하기 때문에,스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 감소된다.
 * 처리 비용 감소 및 응답 시간이 단축된다.
   
  * 프로세스 간의 통신(IPC) 보다 스레드 간의 통신 비용이 적으므로 작업들 간의 통신 부담 감소.
  * 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.
    
  * 주의사항
      * 안정성 측면에서는 멀티 프로세싱이 안정적이며, 멀티스레드는 동기화 문제가 발생할 수 있다.
      * 스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다.



## 스레드와 동시성(Concurrency)

### 1. 스레드(thred)

* 프로세스 내에서 실행되는 흐름의 단위.
* 일반적으로 한 프로그램 당 하나의 스레드를 갖지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행 시킬 수 있는데, 이를 멀티 스레드 라고 한다.
* 스레드를 지원하는 주체에 따라, 사용자 레벨 스레드와 커널레벨 스레드로 나뉜다.
  * 사용자 레벨 스레드:
    * 사용자 레벨의 라이브러리를 통해 구현. 라이브러리에서 스레드의 생성 및 스케줄링에 대한 관리 기능 제공.
    * 속도가 빠르지만, 하나의 시스템이라도 중단 될 경우, 전체 스레드가 중단된다.
  * 커널 레벨 스레드:
    * 운영체제가 지원하는 스레드 기능으로 구현. 커널이 스레드 생성 및 스케줄링에 대한 관리 기능 제공.
    * 속도가 사용자 스레드보다는 느리지만, 하나의 스레드가 종료되어도, 전체 스레드가 종료되지않고 실행된다.
* 스레드의 데이터에는 고유한스레드의 정보를 갖는 **기본데이터**와, 멀티 스레드에서 개별 스레드만의 자료 공간이 필요할 경우 사용되는 **특정 데이터**가 있다.



### 2. 동시성(Concurrency)

* 병행성이라고도 한다.
* 동시성(병행성)은 2개 이상의 Task가 진행(making process)되고 있는 것이다.
* 운영체제가 프로세서 시간을 나눠, 여러 프로세스를 빠르게 전환하여 실행하는 방식.
  싱글코어에서 멀티쓰레드를 동작시킨다.
* 논리적인 개념이며, 다중 프로그래밍 시스템에서 가질 수 있는 성질이다.



### 3. 병렬성(Parallelism)

* 단순히 동시에 실행 되는 것 처럼 보이는 동시성과는 달리, 실제로 동시에 여러 작업이 처리 되는 것.
* 멀티 코어에서 멀티 쓰레드를 동작시키는 방식이다.
* 한 번에 많은 일을 처리하며, 물리적 개념을 가지고 있다.





### 4. 비동기(Asynchronous) 프로그래밍

* 프로그램의 주 실행 흐름을 멈춰, 기다리는 부분 없이 바로 다음 작업을 실행할 수 있는 방식.
* 코드의 실행 결과 처리를 별도의 공간에 맡긴 뒤, 결과를 기다리지 않고 다음 코드를 실행하는 **병렬 처리 방식.**



## 기본적인 네트워크 개념

### 1. 네트워크란?

* Net+Work 의 합성어. 컴퓨터들이 통신 기술을 이용하여 그물망 처럼 연결된 통신 이용 형태.
  주로 통신망으로 불림.

* 전송 매체를 링크로 서로 연결된 장치(또는 노드)의 모임.

  > 노드(node)?
  > 컴퓨터나 프린터, 스마트폰, 노트북, 데이터 송수신 등의 통신망(telecommunications network)

  



#### 프로토콜

* 네트워크를 통합하여 컴퓨터끼리 통신을 하는 데 있어, 상호간에 정해진 집합 통신 절차, 규약.
* 서로 언어(프로토콜)가 다르기 때문에, 대화(통신)가 불가능 한 상황이 벌어질 수있기 때문에, 어떤 언어를 쓰자는 약속이다.



### 2. 네트워크 구성 요소

* 하드웨어적 요소
  - **Network Interface Card (NIC)**: LAN 카드(컴퓨터 메인보드 랜)
  - **Network Servers**: File Servers, Mail Servers, Printer Servers, DB Servers 등
  - **LAN 주변장치**: 프린터, 대용량 저장장치, 모뎀, 팩스
  - **LAN Workstation**: PC, UNIX 등 - 라우터, 스위치, 허브, 커뮤니케이션 서버, 파이어월
* 소프트웨어적 요소
  - **Network Operating System**: Netware(IntraNetWare), Windows NT Server 등
  - **Communication Software**: TCP/IP Software , VPN 등
  - **LAN Applications**



### 3. 네트워크 분류

네트워크의 분류는 전송방식,연결 형태, 망의 규모, 통신 방법, 서비스 별로 구분된다.

* 전송방식

  * 아날로그 통신망:
    음성이나 화상등의 아날로그 정보를 핀폭, 위상, 주파수 형으로 전송
  * 디지털 통신망:
    데이터 통신망과 상호 접속시켜 음성, 데이터 등 다양한 서비스 제공

* 연결 형태

  * 링형(Ring)
    * 각 노드의 좌우의 인접한 노드와 연결되어 원형을 이루고 있는 네트워크 구조.

    * 장점: 단 방향 통신으로 신호 증폭이 가능하여 거리제약이 적음.

      단점: 노드의 추가 삭제가 용이하지 않고, 설치비용이 많이 듬.

    ![img](https://camo.githubusercontent.com/3602ef25d01326df06c21c67d681fa44b7b7312f/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323435364236333935383134423537393143)

  * 성형(Star)
    * LAN에서 가장 널리 사용되는 물리적 토폴로지.

    * 중앙의 연결지점에 허브, 스위치, 라우터 같은 방지가 배치되며, 각 노드는 중앙에 위치한 주 노드를 통하여 다른 노드들과 통신할 수 있는 네트워크 구조.

    * 장점: 장애 발견이 쉽고, 관리가 용이.

      단점: 주 노드에 장애가 발생할경우, 전체 네트워크 사용이 불가능.

    ![img](https://camo.githubusercontent.com/76d53e7bac3c4058280516597460adc9fd4f5ab8/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323631343543334335383134423634443138)

  * 버스형(Bus)

    - 버스라는 공유 통신 경로를 통해 연결된 클라이언트의 집합을 가리키는 네트워크 구조.

    - 장점: 노드의 추가 및 삭제가 용이. 특정 노드의 장애가 다른 노드에 영향을 주지 않음.

      단점: 공통 배선의 대역폭을 공유하기 때문에, 노드 수가 증가하면 배선의 트래픽이 증가하여 네트워크 성능 저하.

    ![img](https://camo.githubusercontent.com/52b3776345e97096c86bacdb3a404324dc02e3cf/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323134424230333935383134423537393241)

  * 망형(Mesh)

    - 모든 노드가 서로 일대일로 연결된 그물망 형태.

    - 다수의 노드 쌍이 동시에 통신할 수 있으며, 완전 연결형과 부분 연결형으로 나뉜다.

      - 완전 연결형: 스위칭 혹은 브로드 캐스팅이 필요 없지만, 노드가 추가 될 때마다 연결 수가 급격히 증가.

    - 장점: 하나의 노드에 장애가 발생해도 다른 노드에 영향을 주지않음. 회선 장애에 유연한 대처가 가능.

      단점: 회선 구축 비용이 많이 든다. 새로운 노드 추가시 비용부담 발생.

    ![img](https://camo.githubusercontent.com/57e02807242593237d56d3c5168ecd32e898df64/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323134394333333935383134423537423244)

    ![img](https://camo.githubusercontent.com/9e2ea20cd7061c8af844cecb3d50b84c4fc6ed3c/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323534423730333935383134423537413241)

* 망의 규모

  * PAN(Personal Area Network) 
    * 가장 작은 규모의 네트워크. 개인용 정보 단말기들 간에 정보를 주고받을 수 있도록 구성되었다.
    * 기업이나 캠퍼스에서 주로 사용하고 있다.(2km 이내 사용 가능.)
  * LAN(Local Area Network)
    * 조직 단위, 사무실 등 한정된 영역을 연결하기 위한 지역적 네트워크.
      제한된 지역에서 여러대의 장치들을 서로 연결하는 독립적인 네트워크다.
    * 유지비용이 적게 들고, 직접 관리가 용이하지만, 초기 투자비용이 높다.
    * 서울시 행정망, 대덕 연구단지망, 지역케이블 방송망 등에서 사용한다. .(10km~50km 이내 사용 가능.)
  * WAN(Wide Area Network)
    * 물리적으로 넓은 범위를 연결하는 광역 네트워크. 서로 관련이 있는 LAN들을 상호 연결한다.
    * 초기 설치비용은 적지만, 유지비용이 많이 든다.
    * 서비스 제공업체에서 관리를 하여, 관리가 용이. 사용 범위는 1개 국가다.
      ex) KT, DACOM

* 통신 방법

  * 회선 교환망(Circuit Swithcing Network): 

    * 통신을 원하는 두 지점을 교환기를 이용해, 물리적 접속시키는 방식. 
      음성 전화망이 대표적이다.

  * 패킷 교환망(Packet Switching Network): 

    * 정보의 송수신을 패킷 교환 방식으로 실현하는 교환 망.
      인터넷이 대표적이다.

    > 패킷?
    > 데이터 전송에서 사용되는 데이터 묶음.

  * 시분할 교환망(Message Switching Nework): 

    * 교환기가 호출자의 전체 메세지를 받았다가, 이를 적절한 경로를 통해 수신자에게 전달하는 교환망.
    * 메세지 전달이 주 목적으로, 빠른 응답을 요구하는 응용에는 부적합하다.

* 서비스 별

  * 부가가치 통신망 (VAN, Value Added Network):
    공중 통신 사업자로부터 회선을 대여받아 고도의 통신 처리 기능으로 부가 가치를 높여 서비스를 제공하는 통신망이다.
  * 종합정보통신망( IDSN, Integreated Services Digital Network):
    성격이 다른 서비스를 종합적으로 취급하는 디지털 통신망이다.
  * 공중망 (Public Network):
    통신 사업자나 통신 주관청이 제공하는 교환 접속형 통신망이다.

### 3. 네트워크의 세분화 (OSI 7 Layer Model)



1. Layer

   - 기능적으로 비슷한 역할을 수행하는 protocol의 집합.
   - 동일한 layer 안에 여러개의 protocol이 있을 수 있다.

2. Model

   - 통신이 진행되는 순서에 따라 protocol layer를 배치한 것.
   - 현재 사용되는 Model: OSI 77 Layer Model, TCP/IP Protocol Model

3. OSI 7 Layer Model vs TCP/IP Model

   |      | OSI 7 Layer Model | TCP/IP Model               |
   | ---- | ----------------- | -------------------------- |
   | 7    | Application       | Application                |
   | 6    | Presentation      | Application                |
   | 5    | Session           | Application                |
   | 4    | Transport         | (Host - to Host) Transport |
   | 3    | Network           | Internet                   |
   | 2    | Data Link         | Network Interface          |
   | 1    | Physical          | (Hardware)                 |

4. 각 Layer 소개

   | 계층  | Layer                   | 기능                                                         | 프로토콜                   |
   | ----- | ----------------------- | ------------------------------------------------------------ | -------------------------- |
   | 7계층 | Application (응용)      | 네트워크 데이터를 만들기 위한 사용자 응용 프로그램           | FTP, Telnet, http, smtp 등 |
   | 6계층 | Presentation (표현)     | Application에서 만들어진 데이터를 독립화 시키고 네트워크에 보편적인 데이터로 전환 | XDR 등                     |
   | 5계층 | Session (세션)          | Application간의 연결을 설정하거나 종료 시키고, 레이어 양단의 Application의 대화 교환, 종료를 담당함. | 인증, 세션설정 등          |
   | 4계층 | Transport (전송)        | 전송 될, 혹은 전송된 데이터의 품질을 보증하는 영역<br />전송계층에는 TCP와 UDP라는 통신수단이 존재한다.<br/>\- **TCP **: 신뢰성을 바탕으로 통신을 하는 방식. 데이터를 전송하는 과정에서 데이터의 누락이 발생시, 누락된 부분을 확인하여 다시 전달하는 통신 방식이다 <br/>\- **UDP** : TCP와 다르게 비신뢰성을 바탕으로 통신. 데이터를 전송하는 과정에서 데이터의 누락 발생시, 누락된 부분을 확인하지않고, 바로 다음 데이터를 전송. | TCP, UDP                   |
   | 3계층 | Network (네트워크)      | 전송에 필요한 주소를 사용하는 영역<br />전체 네트워크 장비들끼리의 통신을 관리하고 통신을 끝까지 하는 것에 대한 규정. | IP, ICMP 등                |
   | 2계층 | Data Link (데이터 링크) | 논리적인 데이터를 전송하기 위해 물리적인 형태로 변환하는 영역 | Ethernet 등                |
   | 1계층 | Physical (물리)         | 물리적 전송계층으로 네트워크 케이블,연결방식을 의미          | 랜선, 허브                 |

   - OSI 7 Layer Model 와 TCP/IP Model의 차이: Application, Presentation, Session layer 기능이 TCP/IP Model 에서는 통합되어있다.
   - 7가지의 계층을 나눈 이유:
     * 데이터의 흐름을 한 눈에 파악
     * 장비들의 네트워크 구성을 위해 계층별로 장비를 나누어 표현하여, 보다 쉽게 다가갈 수 있음.
     * 각 층별로 표준을 만들어, 서로 다른 장비끼리도 상호운용이 가능하게 하도록 위함.
   - 계층에 속하는 장비:
     ![image](https://user-images.githubusercontent.com/69128652/97574154-26667a00-1a2e-11eb-93fa-ea80bb551e51.png)

