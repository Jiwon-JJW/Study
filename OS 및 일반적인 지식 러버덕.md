# OS및 일반적인 지식

## OS(Operating System : 운영체제)

### 1. 운영체제(OS)란?

* 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하게 사용할 수 있도록 환경을 제공 하는 프로그램의 모임.
* 컴퓨터와 하드웨어(CPU,I/O) 위에 설치 되어, 사용자 및 다른 소프트 웨어와 하드웨어를 연결하는 중개자 역할을 한다.
  이 때, 자원의 공유 및 분배를 위한 policy를 제공한다.
* Abstraction : 사용자를 위하여 제공되는 것.
  * 프로그램(program): 컴퓨터를 실행시키기 위해 순차적으로 작성된 명령어 모음. 
  컴퓨터 시스템의 disk와 같은 scondary storage에 바이너리 형태로 저장된다.
  * 프로세스(process): 실행되고 있는 프로그램의 추상화.
    > 추상화? </br>가상 메모리를 사용하여 메모리를 늘린것과 같이 사용하거나, 멀티태스킹 같은 역할을 하는 것.
  * 주소공간(Address Space): 프로세스가 차지하는 메모리 공간. 서로의 주소공간을 침범할 수 없다.
  * 파일(File): 프로세스에서 읽고 쓸 수 있는 Persistent storage.
  * 포트(port): 컴퓨터간에 메세지를 주고받는 communication end point. 여러가지 프로세스가 네트워크 내에서 섞이지 않게 만들어줌.
  * 커널(Kernel): 운영체제의 핵심. 시스템의 모든것을 통제 함.
    > 커널의 역할:</br>보안, 자원관리, 추상화.
    
#### 운영체제의 역할
  
  1. 프로그램들이 자원을 필요로 할 때, 자원을 할당함. 한정적인 자원을 효율적으로 관리.
  2. 자원을 할당받은 프로그램들이 서로의 영역 또는 자원을 침범을 하지않게 하고, 컴퓨터의 부정사용을 방지하는 **제어프로그램**의 역할을 함.

#### 운영체제의 구조

* 멀티 프로그래밍
  * 메모리에 여러 Job(프로그램, 프로세스 통칭)을 저장해두고, 하나의 Job실행 도중 I/O작업 등이 발생하여 유휴시간이 생겼을 때 다른 Job을 시작하여 CPU의 효율성을 증가시킨다. </br>여러개의 작업(Job)을 메모리에 동시에 유지시킴.
  * 하지만, 사용자가 실행중인 작업에 관여할 수 없어, 우선순위가 높은 작업을 먼저 처리해야하는 경우 문제가 발생할 수 있다.
  </br>(이 때, Job Scheduling으로도 해결 할 수 없다.)
* 타임 셰어링
  * 멀티 프로그래밍에서 확장된 개념. 멀티 태스킹이라고도 한다.
  * CPU가 스케쥴링을 통해 작업들을 빠르게 Switching하면서, 동시에 프로그래밍이 구성되는 것 처럼 느껴지게한다.
  * 메모리가 모자라는 경우, 스와핑을 통해 프로세스를 가상메모리에 저장.
  
  
### 2. 운영체제의 작동(Operating System Operations)
* 현대의 운영체제는 인터럽트를 기반으로 한다.
* 실행할 프로세스가 없다면 운영체제도 작동하지 않고, 인터럽트나 트랩이 발생하면서 이벤트 발생.
  * 인터럽트(Inturrupt): CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요한 경우, </br> CPU에게 문제를 알려, 처리할 수 있도록 하는 것.
    * 인터럽트의 대응이 끝난 후, 그 다음 명령어를 수행하거나 대기 상태로 돌입하기 위해, OS는 명령어의 주소를 저장한다.
    * 인터럽트의 종류:
    </br> 외부 인터럽트: 키보드,마우스 등과 같이 외부에 기반하여 발생하는 인터럽트
    </br> 내부 인터럽트: 프로그램 안에서 실행되는 인터럽트.
    
    
 * 하드웨어 보안
  * 듀얼모드:
    * 운영체제가 유저모드와 커널모드로 나누어 동작하는 것.
    > 유저모드:
    </br> * 커널 모드에 비해 낮은 권한의 실행모드.
    </br> * Privilege 명령어 실행 불가능.
    </br> * 어플리케이션이 실행되며, 시스템에 영향을 주는 연산을 사용할 수 없어 하드웨어 보안을 유지시킨다.
    </br> * 유저 어플리케이션이 커널모드에서만 제공되는 인스트럭션을 사용하려는 경우, 유저모드 프로세스 내에서 비트(Bit)를 변경하는 시스템 콜을 실행한다.
    
    > 커널모드:
    </br> * 모든 권한을 가진 실행모드.
    </br> * 운영체제가 실행되는 모드.
    </br> * Privilege명령어 실행 및 레지스터 접근 가능.
    
    
    
## 터미널
### 1. 터미널이란?
* 키보드와 모니터 등으로 이루어진 단말기. 컴퓨터와 소통하기 위해 키보드를 사용하는 것.
* 주로 명령줄 모드(CLI,Command Line Interface)를 나타내는 말이다.</br>
텍스트 기반 명령을 입력하고 실행할 수 있는 인터페이스.

* 기술적으로는 다른 의미이지만, Terminal, Console, Shell, Command Line으로 불리기도 한다.
  * 콘솔(console)
  * 커멘드 라인(명령줄, command Line): 명령을 입력하는 모든 것.
  * 쉘(Shell): 명령 실행을 위한 응용 프로그램. 터미널로 쉘을 실행시킨다.
  
#### 사용하는 이유
* 일부의 경우, 그래픽 응용 프로그램 및 메뉴보다 터미널을 사용하여 작업을 완료하는 것이 빠르기 때문.
* 더 많은 명령과 스크립트에 액세스 할 수 있기 때문.
  
### 2. CLI/ TUI/ GUI
> Shell을 기본적으로 사용하고 있다.
> Shell: 사용자가 명령을 내리면, 그 명령을 해석하여 커널에 전달해주는 인터페이스 역할. 크게 CLI와 GUI로 나뉜다.
* CLI(Command Line Interface)
  * 가상 터미널을 통해 사용자와 컴퓨터가 문자열 형태로 입출력을 주고받는 형태의 인터페이스. 명령줄 인터페이스라고도 한다.
  * 서버 관리 및 프로그래밍 분야에서 사용되며, GUI에 비해 자원을 적게 소모하고 안정적이다.
  * 사용 예: 도스, 명령 프롬프트, 유닉스 쉘 등.
  
 * TUI(Text-based User Interface)
  * 터미널 사용자 인터페이스라고도 한다.
  * 텍스트 기반 사용자 인터페이스로, 화면에 글자만을 이용해 레이아웃 표현도 가능하다.
  * GUI와 같이 화면 전반을 사용하며, 마우스와 다른 입력을 할 수 있다.
  
 * GUI(Graphical User Interface)
  * 사용자의 편의성을 위해 입출력 등의 기능을 아이콘이나 그래픽으로 표시한다.
  * CUI보다 직관적으로 조작할 수 있다.
  * 컴퓨터 뿐만 아니라, MP3플레이어 등 수많은 휴대용 모바일 장치에도 사용된다.
  
### 3. 터미널 환경
* 대부분의 백엔드 시스템이 리눅스 기반의 서버에서 운영되기 때문에, 텍스트 터미널을 통해 작업하는 경우가 많다.
* Windows 는 CMD, Mac OS 는 Terminal이 CLI제공 응용프로그램이다.</br> **입력 과 출력**으로 구성된다.
  * Command Prompt(명령 프롬프트) : </br>
    windows: '>'
    </br> Mac OS, Linux: '$'
    * 사용자는 이 부분에 명령어를 입력하여 사용한다.
   * 명령 프롬프트를 통해 특정 명령어를 입력 받고, 셀프로그램이 해당 명령어를 해석하여 적절한 내용을 터미널에 출력한다.
### 4. 자주 사용 되는 명령어
* 운영체제와 상관 없이 공통적으로 자주 사용되는 명령어.
1. ls, dir: 지정한 파일 또는 디렉토리를 표시한다.
  </br> ls: Mac OS, Linux 등 bash프로그램을 사용하는 터미널의 경우.
  ``` $ ls
$ ls -a # 숨김파일까지 확인 가능
$ ls -la # 상세보기 la 만 사용 가능
```
  </br> dir: Windows, DOS기반 명령 프롬프트를 사용하는 커맨드의 경우.
  ```
  > dir
  ```
2. cd: change directory의 약자. 다른 디렉토리로 이동.
```
$ cd <현재 디렉토리의 폴더 이름>  // 폴더로 이동
$ cd <디렉토리>               // 특정 디렉토리로 이동
$ cd ../                    // 상위 디렉토리로 이동
$ cd ~                      // 루트 디렉토리로 이동
```
3. sudo: superuser do. 현재 계정(일반 사용자)에서 root 권한을 이용하여 명령어 실행.
```
// sudo 다음에 실행할 명령을 입렵하면 root 권한으로 명령어를 실행

$ sudo apt-get update
```

4. pwd: print working directory의 약자. 현재 작업중인 디렉토리의 절대 경로를 출력한다.
```
[root@localhost bin]# pwd
/usr/bin
[root@localhost bin]#
```

5. mkdir: make directory의 약자. 새로운 디렉토리 생성.
```
$ mkdir [옵션] 생성할 디렉토리 이름

$ mkdir linux // 현재 경로에 linux 라는 디렉토리 생성
$ mkdir -p girls/tiffiny // 상위 디렉토리 경로를 포함하는 디렉토리 생성
```

6. rm: remove의 약자. 하나 이상의 파일을 삭제할 때 사용. 옵션값을 입력하면 디렉토리 삭제도 가능하다.
```
$ rm [옵션] 파일명/디렉토리명

$ rm -f test.txt // test.txt 라는 파일을 삭제 여부 묻지 않고 강제 삭제
```


## 메모리
### 1. 메모리의 종류
* RAM(Random Access Memory):
  * 전원 공급을 끊으면 기록한 데이터가 소실되는 휘발성 메모리. 프로그램이나 데이터를 일시적으로 저장하는 용도로 사용.
  * 크게 SRAM(Static RAM) 과 DRAM(Dynamic RAM)으로 분류 된다.
    * SRAM:
    </br> 제어가 쉽고 읽기/쓰기 동작이 고속이다.
    </br> 셀 면적이 크기 때문에 대용량화에 적합하지 않고, 가격이 비싸다.
    * DRAM:
    </br> 정기적으로 리플레시 신호를 주지않으면 데이터가 소실된다. 제어가 복잡함.
    </br> 셀 면적이 작기 때문에 대용량화에 적합하다. 가격이 SRAM보다 저렴.
    </br> 대표적으로 SDRAM이 존재한다.
    
* ROM(Read Only Memory):
  * 읽기 전용 메모리. 데이터가 소실되지 않는 비휘발성 메모리. 다시 작성할 필요가 없는 프로그램이나, 데이터 저장에 사용.
  * 크게 mask ROM 과 PROM(Programmable ROM)으로 나뉜다.
    * Mask ROM:
    </br> 일반적인 ROM
    </br> 제작시 데이터를 저장해두고, 이후 지우거나 덮어씌우는 것이 불가능.
    * PROM:
    </br> 사용자가 데이터를 1회 기록할 수 있는 ROM.
    </br> OTP,EPROM,EEPROM등으로 나뉜다.
      * EPROM:
      </br> 저장되어 있는 데이터를 쓰고 지울 수 있는 ROM. 데이터를 지우는 방법에 따라 EEPROM, UVEPROM 으로 나뉜다.
      
* Flash Memory:
  * EPROM의 한 종류. 기존 PROM 종류보다 더 빠르게 기록/ 삭제가 가능한 메모리.
  * 구조에 따라서 NOR과 NAND형 메모리로 분류 된다.
  
### 2. 가상 메모리
  * 메모리를 관리하는 방법 중 하나. 각 프로그램에 실제 메모리 주소가 아닌, 가상의 메모리 주소를 주는 방식.
   </br> 이 때 디스크 상에 존재하는 파일을 Paging file 이라고 한다.
  * 멀티태스킹 운영체제에서 흔히 사용되며, 실제 주기억장치(RAM)보다 큰 메모리 영역을 제공하는 방식 사용.
  * 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽거나 쓸 때에만 물리주소로 바꿔준다.
    * virtual address (가상주소) : 프로세스가 참조하는 주소
    * physical address (물리주소) : 실제 메모리 주소
    
   * MMU (Memory Management Unit) : 
   </br> cpu에서 코드 실행시, 가상 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치.
#### 3. 매핑
* MMU하드웨어에 의해 지원되는 기능.가상메모리와 실제 메모리 사이의 중계를 맡고 있다.
* Paging과 Segmentation, 이 두가지 방식을 혼합한 방법. 총 3가지로 분류된다.

* 페이징(Paging) 기법
  * 컴퓨터가 메인 메모리에서 사용하기 위해 데이터를 저장하고 검색하는 메모리 관리 기법.
  * 가상 메모리 상의 주소 공간을 일정한 크기로 분할한다. 주소 공간은 페이지 단위로 나뉘어져 있으며, 실제 기억 공간은 페이지 크기와 같은 프레임으로 나누어 사용함.
    * Frame: 물리 메모리를 일정한 크기로 나눈 블록
    * Page: 가상 메모리를 일정한 크기로 나눈 블록.
  * 페이징 기법 사용시, 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화(External fragmentation)를 해결 할 수 있다.
    
* 세그멘테이션(Segmentation)
 * 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할하고 메모리를 할당하여 주소를 변환한다.
 * 각각의 세그먼트들은 연속적인 공간에 저장되어있으며, 세그먼트들의 크기가 서로 다르기 때문에, 메모리를 페이징 기법처럼 미리 분할해 둘 수 없다.
 * mapping을 위해 세그먼트 테이블이 필요.
 * 하나의 세그먼트 단위로 메모리를 통제할 수 있어, 내부 단편화가 발생하지 않지만,
 </br> 서로 다른 크기의 세그먼트들을 동적 관리 하므로, 외부 단편화가 생길 수 있다.
 
### 4. 메모리계층 구조
* 레지스터, 캐시: CPU내부에 존재. 빠르게 접근할 수있다.
* 메모리: CPU외부에 존재. 레지스터,캐시보다 느리게 접근.
* 하드디스크: CPU가 직접 접근할 방법 없음. 아주 느린 접근밖에 불가능 하다.
![](https://user-images.githubusercontent.com/69128652/96000303-b5419700-0e71-11eb-82c9-dd2b3fdac552.png)

* 메모리를 필요(대부분의 경우, CPU가 메모리에 빨리 접근하기 위함)에 따라 여러가지 종류로 나누어 둠(계층화)을 의미한다.

* 메모리 계층 구조의 필요성:
  * 자주 쓰이는 데이터는 계속 쓰인다. (참조의 지역성): 자주 쓰이는 데이터는 전체 데이터의 일부이기 때문에, 상위 메모리의 용량이 하위 메모리의 용량보다 작아도 된다.
  * 디코딩(명령 해독 단계) 속도: 여러 개의 메모리를 사용 할 시, CPU는 자신이 원하는 메모리에 접근 해야한다. 이 과정에서 컨트롤 신호를 해석해야하는데, 메모리가 클수록 해당 비용이 증가한다.
  * 경제성: 상위 계층의 메모리일 수록 가격이 올라간다.
 
## 프로세스
* 컴퓨터에서 연속적으로 실행 중인 컴퓨터 프로그램. 운영체제 내에서 프로세스 관리가 중요하다.
* job,task 등과 같은 이름으로 불리기도 한다.
* 여러개의 프로세서를 사용하는 것을 멀티 프로세싱, 같은 시간에 여러개의 프로그램을 띄우는 시분할 방식을 멀티태스킹 이라고 한다.

### 1. 프로세스 상태
* 생성(create): 프로세스가 생성되는 중이다.
* 실행(running): 프로세스가 CPU를 차지하여 명령어들이 실행되고 있다.
* 준비(ready): 프로세스가 CPU를 사용하고 있지는 않지만, 언제든지 사용할 수 있는 상태.일반적으로 준비상태의 프로세스 중 우선순위가 높은 프로세스가 CPU를 할당받음.
* 대기(waiting): 보류(block)라고 부르기도 한다. 프로세스가 입출력 완료, 시그널 수신 등 어떤 사건을 기다리고 있는 상태.
* 종료(terminated): 프로세스의 실행이 종료 된 상태.

### 2. 프로세스의 상태전이
1. 하나의 프로그램 실행 시, 그 프로그램에 대응되는 프로세스가 생성되어 준비리스트의 끝에 들어간다.
2. 준비 리스트 상의 다른 프로세스들이 CPU를 할당받아 준비 리스트를 떠난다.
3. 점차 준비 리스트의 앞 순서로 나가게 되고, CPU를 사용할 수 있게 됨.
  * 디스패치(dispatch): 준비 리스트의 맨 앞에 있던 프로세스가 CPU를 점유하게 되는 것. ( 준비 상태-> 실행 상태)
  * 보류(block): 실행 상태의 프로세스가 허가된 시간을 다 쓰기 전에 추가적인 입출력 동작을 필요로 하는 경우, 프로세스는 CPU를 반납하고 보류상태로 넘어가게 되는 현상.
  * 깨움(wakeup): 입출력 작업 종료 등, 기다리던 사건이 일어났을 때 보류 상태에서 준비 상태로 넘어가는 과정.
  * 시간제한(timeout): 프로세스가 프로세서를 독점하지 못하기 위해 clock interrupt를 둔 것. 프로세스가 일정 시간 동안만 프로세서를 점유할 수 있도록 한다.
  
### 3. 프로세스의 동시 실행
* 하나의 CPU(프로세서)는 한 순간에 하나의 프로세스만 실행할 수 있다.
* 운영체제가 빠르게 CPU가 실행할 프로세스를 교체하고 있기 때문에, 여러개의 프로세스가 실행 되고 있다고 느끼는 것이다.

### 4. 프로세스간 통신(IPC: Inter-Process Communication)
* 프로세스들 사이에 서로 데이터를 주고받는 행위 혹은, 그에 대한 방법이나 경로.
* 프로세스간의 통신을 위해 PIPE 같은 개념이 생성되었다.

#### PIPE
* 프로세스는 메모리 공간을 복제하기 때문에, 통신을 위해 메모리 공간을 할당해주어야한다. 이 때 사용되는 기술.
* 통신을 위한 메모리 공간(버퍼)을 생성하여 프로세스가 데이터를 주고받게 끔 해준다.
* 단방향 통신이라는 특성 때문에, 자원의 낭비가 심하다는 단점이 있다.
* PIPE의 종류:
  * 익명 파이프(Anonymous Pipe):
    * 외부 프로세스에서 사용할 수 없는 파이프. 프로세스가 자식 프로세스를 생성하는 경우, 파일 지정 번호를 상속받아 통신할 수 있다.
    * 사용이 제한적.
  * 네임드 파이프(Named Pipe):
    * 읽기/쓰기가 모두 가능하지만, 한번에 한 방향으로만 통신이 가능한 반이중통신.
    * 전이중통신을 읽기 위해서는 읽기 파이프, 쓰기 파이프를 각각 생성해야한다.
    * 다수의 클라이언트를 처리하기엔 비효율적이다.
    
#### Unix Domain Soket
* 소켓 함수와 기술을 그대로 사용한 것. 유닉스 서버에서 서버/클라이언트 환경을 만들 수 있다.
* 서버/클라이언트 환경을 구축하는데 용이하여, 중대형 어플리케이션에서 주로 사용.

#### 공유 메모리 (Shared Memory)
* OS가 제공하는 메모리를 프로세스들이 공유하는 메모리.
* 대량의 정보를 다수의 프로세스에게 배포가 가능하며, 빠르고 효율적이지만 공유 메모리 공간에 대한 접근 제어가 필요하다.
    
### 5. 프로세스와 스레드의 차이
* 프로세스: 생성되면서 메모리 공간 등을 복사하여 자원을 할당.
  * 정적인 프로그램과 달리, 프로세스는 실제 실행 중인 프로그램을 일컫기 때문에 동적이라고 표현하기도 한다.
  * 한 프로그램에서 실행되는 여러 프로세스가 동시에 존재할 수 있다.
  * Process Control Block(PCB)이라고 하는 자료구조 안에 커널 스케쥴러가 프로세스를 제어하는 데 필요한 정보들이 담겨 있다.
  
* 스레드: 메모리 공간과 자원들을 공유. 실제로 작업을 수행하는 일군이다.
  * 하나의 프로세스가 생성되면 다른 하나의 스레드가 같이 생성되며, 이를 메인 스레드라고 한다.
  * 여러 개의 스레드를 가질 수 있으며, 이 때의 스레드를 멀티 스레드라고 한다.

* 시스템 자원을 효율적으로 관리하기 위해, 하나의 프로세스에서 스레드로 나눠가면서 작업을 진행하게 된다.
  * 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원의 효율적인 관리가 가능.
  * 프로세스 간의 통신보다 스레드 간의 통신의 비용이 적으므로, 작업들간의 통신 부담 줄임.
   </br> 스레드 사용시, 자원의 효율성이 증가하지만, 동기화 문제에 신경써야 한다.

### 6. 멀티 프로세스와 멀티 스레드
* 멀티 프로세스(multi-process), 멀티 프로세싱
  * 여러개의 프로세서가 작업을 병렬적으로 처리.
  프로세스가 하나의 작업을 전담하는 것이 아닌, 하나의 작업을 처리할 때도 여러개의 프로세스가 협력적으로 작업을 처리한다.
  * 단일 프로세싱을 이용할 때 보다 비용을 절감하며, 
   </br>프로세스가 작업을 나눠 실행하기 때문에 문제가 발생하여도 영향이 확산되지 않아 신뢰성이 증가한다.
  *  Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생한다.
  </br> 또한, 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching가 발생하면 캐시에 있는 모든 데이터를 모두 리셋하고 다시 캐시 정보를 불러와야 한다.
  
* 멀티 스레드(Multi-threading)
  * 하나의 프로세스를 여러 개의 실행 단위이며, 여러 개의 스레드끼리 자원을 공유하는 것.
  * 윈도우, 리눅스 등 많은 운영체제들이 멀티 프로세싱을 지원하고 있지만 멀티 스레딩을 기본으로 하고 있다.웹서버는 대표적인 멀티 스레드 응용 프로그램
  * 간단한 통신 방법으로 인한 프로그램 응답 시간 단축. 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다.
  * 하지만, 단일 프로세스의 경우 효과 기대가 어려우며 다른 프로세스의 스레드 제어가 불가능 하다.
   </br>또한, 하나의 스레드에 문제 발생 시 전체 프로세스가 영향을 받거나, 동기화 문제로 자원 공유의 문제가 발생할 수 있다.
   
 #### 멀티 프로세스로 할 수 있는 작업을 멀티 스레드로 하는 이유.
 * 자원의 효율성 증대
  * 프로세스를 생성하여 자원을 할당하는 시스템 호출(System Call)이 줄어들어 자원을 효율적 관리 가능.
  * 스레드는 프로세스 내의 메모리를 공유하기 때문에,스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 감소된다.
  
 * 처리 비용 감소 및 응답 시간 단축
  * 프로세스 간의 통신(IPC) 보다 스레드 간의 통신 비용이 적으므로 작업들 간의 통신 부담 감소.
  * 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.
 * 주의사항
  * 안정성 측면에서는 멀티 프로세싱이 안정적이며, 멀티스레드는 동기화 문제가 발생할 수 있다.
  * 스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다.
