# OS 및 일반적인 지식

## OS(Operating System : 운영체제)

* OS는, IT에서 중요한 S/W이다. 최근에는 H/W보다 S/W가 IT기술 발전에 더 크게 기여하고 있다.
* 다양한 스마트 디바이스들이 존재하고, 기업이 제공하는 플랫폼 위에서 다양한 어플리케이션을 개발한 시대이므로, OS의 기본을 이해하고 나면 활용할 수 있는 기술들이 많아진다.
  

### 1. 운영체제(OS)란?

* 운영체제(OS: Operating System): 컴퓨터 시스템의 자원들을 효율적으로 관리 하며, 사용자가 컴퓨터를 **편리하고 효과적으로 사용할 수 있도록 환경을 제공(abstraction을 제공)하는 여러 프로그램의 모임**. 
  * ex) CPU - process가 관리, Memory - address space가 관리, Disk - file이 관리.
* 컴퓨터와 하드웨어(CPU, I/O) 바로 위에 설치되어, 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 중개자 역할을 한다.
  자원의 공유 및 분배를 위한 policy를 제공.



#### Abstraction?

* 프로그램(Program):
  컴퓨터를 실행시키기 위한 일련의 순차적으로 작성된 명령어 모음. 컴퓨터 시스템의 disk와 같은 secondary storage에 바이너리 형태로 저장.

* 프로세스(Process):

  실행되고 있는 프로그램의 추상화(abstraction). Progran counter, stack, data section 등을 포함.

* 주소공간(Address Space):
  프로세스가 차지하는 메모리 공간. Protection Domain으로써, 서로의 주소공간을 침범할 수 없다.

* 파일(File):

  프로세스에서 읽고 쓸 수 잇는 Persistent storage.

* 포트(Port):
  컴퓨터간에 메세지를 주고받는 communication end point. 여러가지 프로세스가 네트워크 안에서 섞이지 않게 만들어 준다.

* 커널(Kernel): 

  운영체제의 핵심 부분. 시스템의 모든 것을 완전하게 통제하는 기능을 한다.

  * 커널의 역할: 보안, 자원 관리, 추상화



#### 운영체제의 역할

1. 프로그램들이 자원(resource)을 필요로 할 때 자원을 할당해준다.

   자원은 한정적이므로, 효율적인 관리를 해준다.
   (자원: CPU 시간, 메모리 공간, 파일 저장 공간, 입출력 장치 등등)

2. 각각 자원을 할당받은 프로그램들이 서로의 영역을 침범 혹은, 자원을 침범하지 않게 하고, 컴퓨터의 부적절한 사용을 방지하는 **제어프로그램의 역할**을 한다.



#### 운영체제의 구조

* 멀티 프로그래밍(Multi-programming)
  * 컴퓨터 내에 CPU와 다양한 I/O장치들이 있다.
    CPU에 들어 간 프로그램이 하나 밖에 없을 때, 프로그램이 입력 대기 상태일 경우, CPU는 작동을 하지 않아 효율성이 떨어진다.
    이를 해결 하기 위해 메모리에 여러 개의 Job(프로그램,프로세스 통칭)을 저장해 두고, 하나의 Job 실행 중 I/O작업 등이 발생해 유휴 시간이 생겼을 때, 다른 Job을 시작하여 CPU의 효율성을 증가 시킴.
    이로서 여러개의 작업(Job)을 메모리에 동시에 유지시킨다.
  * 다만, User가 실행중인 작업에 대해 관여할 수 없어, 다른 작업이 수행되려면 현재 수행 중인 작업이 I/O를 해야한다.(자발적 양보(voluntary yield)에 의존)
    우선순위가 높은 작업을 먼저 처리 해야할 때 문제가 발생할 가능성이 높으며, 이는 Job Scheduling으로도 해결 할 수 없음.
* 타임 셰어링(Time-sharing)
  * 멀티 프로그래밍에서 확장된 개념. 멀티 태스킹(Multi-tasking)이라고도 함.
  * CPU가 **스케쥴링**을 통해 작업들을 빠르게 Switching 하면서, 마치 동시에 프로그래밍이 구성되는 것 처럼 느껴지게 한다.
  * 메모리가 모자라는 경우, 스와핑(swapping)을 통해 프로세스를 가상메모리(Virtual Memory)에 저장한다. 



### 2. 운영체제의 작동 (Operating System Operations)

* 현대의 운영체제는 인터럽트(Inturrupt)를 기반으로 한다.
  실행할 프로세스가 없다면 운영체제도 작동을 하지 않고 기다리고, 어떠한 인터럽트나 트랩이 발생하면서 이벤트가 발생한다.

  * 인터럽트: 인터럽트 발생 시,(ex: 컴퓨터 부팅 시, 암호입력) 인터럽트의 대응이 끝난 후, 그 다음 명령어를 수행하거나 대기상태로 돌입하기 위해OS는 명령어의 주소를 저장한다.

    1. 외부 인터럽트(H/W inturrupt): 키보드, 마우스 등과 같이 외부에 기반하여 발생하는 인터럽트.

    2. 내부 인터럽트(S/W inturrupt): 프로그램 안에서 실행되는 인터럽트.

       

* 하드웨어 보안
  * 듀얼모드(Dual-Mode Execution)

    * 운영체제가 유저모드(User mode)와 커널 모드(Kernel mode)로 나누어서 동작하는 것.

    * 유저 어플리케이션이 운영체제의 중요한 데이터에 접근해서 변경하는 것을 막기 위하여 두 가지 모드로 나눈 것이다.

      > User Mode:
      >
      > * Kernel 모드에 비해 낮은 권한의 실행모드
      > * 어플리케이션이 실행 되는 모드. 시스템에 영향을 주는 연산은 커널모드에서만 실행 가능 해, 하드웨어 보안 유지.
      > * Privilege 명령어 실행 불가능.
      > * CPU 내부에 모드 비트(mode bit)를 두어 사용자 프로그램을 감시한다.
      >   (각각의 명령어에 mode bit가 심어져 있으며, 명령어의 mode bit와 시스템 상의 mode bit가 같을 시에만 명령어 사용 가능.)

      

      > Kernel Mode:
      >
      > * 모든 권한을 가진 실행 모드
      > * 운영체제가 실행 되는 모드
      > * Privilege명령어 실행 및 레지스터 접근 가능.
      >   ex) I/O 장치 제어 명령어, 메모리 관리 레지스터 CR3

    * 유저 어플리케이션이 커널 모드에서만 제공되는 인스트럭션을 사용하려는 경우, 유저 모드 프로세스 내에서 비트(Bit)를 변경하는 **시스템 콜(System call)**을 실행한다.

      > 시스템 콜(System call):
      > OS의 커널이 제공하는 서비스에 대해, 응용프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스.
      > 프로그래밍 언어에서 지원하지 않는 기능에 대하여 운영체제의 루틴을 호출하여 이용하는 것.
      >
      > ![img](https://blog.kakaocdn.net/dn/oYzTi/btqyXq5GNUC/T5KVZpgkaS1z1FpkegbKhK/img.png)



## 스케줄링

#### 스케줄링이란?

* 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에 할당하는 작업을 의미.
  다중 프로그램을 가능하게 한다.

* 프로세스가 생성되어 완료될 때 까지 프로세스는 여러종류의 스케쥴링 과정을 거치는데,
  이 때의 스케줄링의 종류로는 장기 스케줄링, 중기 스케줄링, 단기 스케줄링이 있다.

  | 이름          | 설명                                                         |
  | ------------- | ------------------------------------------------------------ |
  | 장기 스케줄링 | 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할것인가를 결정하여 준비상태 큐로 보내는 작업.<br />작업 스케줄링 또는 상위 스케줄링이라고도 하며, 이러한 스케줄링은 작업 스케줄러에 의해 수행. |
  | 중기 스케줄링 | 어떤 프로세스들이 CPU를 할당 받을 것인지 결정하는 작업.<br />CPU를 할당 받으려는 프로세스가 많을 경우 프로세스를 일시 보류 시킨 후 활성하 하여 일시적으로 부하를 조절. |
  | 단기 스케줄링 | 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업.<br />프로세서 스케줄링 또는 하위 스케줄링이라고도 한다.<br />프로세서 스케줄링 및 문맥 교환은 프로세서 스케줄러에 의해 수행. |



#### 스케줄링의 목적

* 스케줄링은 CPU나 자원을 효율적으로 사용하기 위한 정책으로, 아래와 같은 목적을 가지고있다.
  1. 공정성: 모든 프로세스에 공정하게 할당.
  2. 처리율(량)증가: 단위 시간당 프로세스를 처리하는 비율(양)을 증가.
  3. CPU 이용률 증가: 프로세스 실행과정에서 주 기억장치를 액세스 하거나, 입출력 명령실행 등의 원인에 의해 발생할 수 있는 CPU 낭비시간을 줄이고, CPU가 순수하게 프로세스를 실행하는 시간 비율을 증가.
  4. 우선순위 제도: 우선순위가 높은 프로세스를 먼저 실행
  5. 오버헤드 최소화: 오버헤드를 최소화
  6. 응답시간 최소화: 작업을 지시하고,반응하기 시작하는 시간을 최소화.
     (* 응답시간(Respinse Time): 하나의 요청에 첫번째 응답이 나올 때 까지의 시간 )
  7. 반환시간 최소화: 프로세스를 제출한 시간부터 실행이 완료 될 때 까지 걸리는 시간을 최소화.
     (* 반환시간(Turnaround Time): 메모리에 적재되기 위해 기다린 시간, 준비상태 큐에서 대기한 시간, CPU에서 실행하는 시간, 입출력 시간을 합친 시간)
  8. 대기시간 최소화: 프로세스가 준비상태 큐에서 대기하는 시간을 최소화.
     (* 대기시간(Waiting Time): 준비 상태 큐에서 대기하는 시간)
  9. 균형있는 자원의 사용: 메모리, 입출력 장치등의 자원을 균형있게 사용.
  10. 무한 연기 회피: 자원을 사용하기 위해 무한정 연기되는 상태를 회피.



### 프로세서 스케줄링의 기법

#### * 비선점 스케줄링

* 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법.
* 프로세스가 CPU를 할당 받으면, 해당 프로세스가 완료될 때 까지 CPU를 사용. 
* 특징:
  * 프로세스 응답시간의 예측이 용이.
  * 일괄 처리 방식에 적합.
  * 중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우가 발생할 수 있다.
* 비선점 스케줄링의 종류:
  * FCFS, SJF, 우선순위, HRN, 기한부 등의 알고리즘.



#### * 선점 스케줄링

* 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때, 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법.

* 우선 순위가 높은 프로세스를 빠르게 처리할 수 있다.

* 특징:

  * 빠른 응답시간을 요구하는 대화식 시분할 시스템에 사용 됨.

  * 많은 오버헤드를 초래.

  * 선점이 가능하도록, 일정 시간 배당에 대한 인터럽트용 타이머 클록이 필요하다.

    >  인터럽트용 타이머 클록:
    > 하나의 시스템 내에서 동작하는 장치들을 감시하기 위해 주기적인 신호를 발생하는 것.
    > 하나의 프로세스가 자원을 독점하지 못하도록 방지하기 위해 사용.

* 선점 스케줄링의 종류:

  * 라운드 로빈, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등의 알고리즘이 있다.





## 터미널 사용 방법

#### 터미널이란?

* 컴퓨터와 사용자 간의 서로 소통시켜주는 인터페이스. 컴퓨터와 소통하기 위해서 키보드를 사용하는 것을 말한다.
* Shell을 기본적으로 사용하고 있으며, Linux OS에서는 기본적으로 bash,tcsh등이 사용되고 Window에서는 cmd를 기반으로 사용되고 있다.
  * Shell: 사용자가 명령을 내리면, 그 명령을 해석하여 커널에 전달해주는 인터페이스 역할. GUI와, CLI로 나뉜다.
    * GUI(Graphic User Interface): 그래픽 유저 인터페이스. 
      사용자가 편리하고 직관적으로 알아 볼 수 있도록 그래픽으로 입출력등의 기능을 수행해, 송출한다.
      ex) 윈도우를 처음 켰을 때 보이는 아이콘들.
    * CLI(Command Line Interface): 명령어 기반 인터페이스.
      터미널 등의 프로그램을 통해서 문자열을 입력하고, 문자로 반환된 결과를 확인하는 인터페이스.



#### 사용하는 이유

* 일부 작업의 경우, 그래픽 응용 프로그램 및 메뉴보다 터미널을 사용하여 작업을 완료하는 것이 빠르기 때문.
* 더 많은 명령과 스크립트에 액세스 할 수 있기 때문.



#### 사용 방법

* Window 나 UNIX내의 응용프로그램 검색 창에 CMD 혹은 Terminal 입력 후, 원하는 명령어를 입력한다.
  Window 내에선 터미널을 사용할 수 있는 프로그램을 CMD / 명령 프롬프트 라고 불리며,
  UNIX 내에선 터미널을 사용할 수 있는 프로그램을 터미널 이라고 부른다.





## 메모리

### 1. 메모리의 종류

![image](https://user-images.githubusercontent.com/69128652/95991255-81fa0a80-0e67-11eb-9c99-c2f197987273.png)

| 휘발성 메모리            | 비 휘발성 메모리     |
| ------------------------ | -------------------- |
| RAM (랜덤 액세스 메모리) | ROM(고정 기억 장치)  |
| DRAM (동적 램)           | NVRAM(플래시 메모리) |
| SRAM                     | MRAM                 |
| 내용 주소화 기억 장치    |                      |

* RAM(Random Access Memory) :

  * 전원 공급을 끊으면 기록한 데이터가 소실되는 메모리. 휘발성 메모리 이다.
    프로그램이나 데이터를 일시적으로 저장하는 용도로 사용 됨.

  * 크게 SRAM(Static RAM) 과 DRAM(Dynamic RAM)으로 분류 된다.

    * SRAM: 

      * flip-flop circuit을 사용해 데이터를 유지.
      * 전원을 공급하면 데이터를 유지할 수 있는 플립플롭 회로를 사용한 셀구조.
      * 제어가 쉽고, 읽기/쓰기 동작이 고속이다.
      * 셀 면적이 크기때문에 대용량화에 적합하지 않음. 가격이 비싸다.

    * DRAM:

      * Capacitor를 이용해서 데이터를 유지.

      * 커패시터에 전하를 축적함으로 인하여 데이터를 유지하는 커패시티형 셀구조.

      * 정기적으로 리플레시 신호를 주지 않으면 데이터가 소실됨. 제어가 복잡하다.

      * 셀 면적이 작기 때문에 대용량화에 적합하다. 가격이 SRAM보단 저렴하다.

      * 대표적으로 SDRAM 이라는 DRAM이 존재한다.

        * SDRAM(Synchronous DRAM):
          Bus 속도를 빠르게 유지하는 상태로 동작할 수 있도록 만든 메모리.
          시스템의 clock 속도와 동기화(synchronous)가 가능하므로, CPU가 처리할 수 있는 양이 증가한다.

          > DDR SDRAM(Double Data Rate SDRAM):
          > SDRAM보다 2배(double) 빨리 동작한다.
          > 동일 시간에 데이터를 2배로 처리가 가능하기 때문에 효율이 높다.



* ROM(Read Only Memory) :

  * 읽기 전용 메모리. 전원 공급이 끊어져도 기록한 데이터는 소실되지 않는다. 비휘발성 메모리이다.
    다시 작성할 필요가 없는 프로그램이나, 데이터의 저장에 사용된다.

  * 크게 mask ROM 과 PROM(Programmable ROM)으로 나뉜다.

    * Mask ROM: 

      * 일반적인 ROM. 
      * 회사에서 ROM 제작시 데이터를 저장해 두고, 후에 지우거나 덮어씌우는 것이 불가능하다.

    * PROM :

      * 사용자가 바로 데이터를 기록할 수 있는 ROM.

      * OTP, EPROM, EEPROM으로 나뉜다.

        * OTP(One Time PROM) : 
          1회만 쓰기(수정)가 가능한 ROM. 한 번 수정하게 될 경우, 데이터 수정이 불가능하다.

        * EPROM(Erasable PROM) : 
          저장되어 있는 데이터를 쓰고 지울 수 있는 ROM. 데이터를 지우는 방법에 따라 EEPROM, UVEPROM 으로 나뉜다.

          > EEPROM(Electrically Erasable PROM): 
          > 고전압(high voltage)으로 데이터를 지우고, 삭제된 공간에 데이터를 다시 기록할 수 있는 메모리.
          > 비교적 지우는 속도가 느리다.

          

          > UVEPROM(Ultra-Violet EPROM): 자외선을 이용하여 데이터를 지운다.

* Flash Memory:

  * EEPROM의 한 종류. 기존 PROM 종류보다 더 빠르게 기록/ 삭제가 가능한 메모리.
  * 구조에 따라서 NOR과 NAND형 메모리로 분류 된다.
    * NOR: 
      * 데이터 유지에 있어서 에러가 적게 발생한다.
      * 지우기 속도가 느려서, 고속화에 적용되지 못함.
      * 셀 면적이 크기 때문에, 대용량화가 어렵다.
    * NAND:
      * 셀 면적이 작기 때문에, 대용량화에 적합하다.
      * 휴대용 음악 플레이어, 핸드폰 등에서 데이터 저장 용도로 사용된다.



### 2. 메모리 계층 구조 (Memory Hierarchy)

![image](https://user-images.githubusercontent.com/69128652/96000303-b5419700-0e71-11eb-82c9-dd2b3fdac552.png)

* 메모리를 필요(대부분의 경우, CPU가 메모리에 빨리 접근하기 위함)에 따라 여러가지 종류로 나누어 둠(계층화)을 의미한다.
* 속도가 느리고 용량이 큰 기억장치의 내용 중, CPU가 자주 사용하는 데이터를 속도가 빠른 기억장치로 옮겨 놓고 사용함으로써, 
  전체적인 기억장치의 액세스 속도를 개선하는 전략을 사용한다.
* 기억 장치의 성능 평가 기준에는, 액세스 속도, 용량, 가격이 있는데, 이 세가지 특징은 상반되는 경우가 많다.
* 보통 액세스 속도가 빠를수록 용량이 작아지고, 가격이 비싸진다.



#### 메모리 계층 구조의 필요성

* 자주 쓰이는 데이터는 계속 쓰인다. (참조의 지역성): 
  자주 쓰이는 데이터는 전체 데이터의 일부이기 때문에, 상위 메모리의 용량이 하위 메모리의 용량보다 작아도 된다.
* 디코딩(명령 해독 단계) 속도:
  여러 개의 메모리를 사용 할 시, CPU는 자신이 원하는 메모리에 접근 해야한다.
  이 과정에서 컨트롤 신호를 해석해야하는데, 메모리가 클수록 해당 비용이 증가한다.
* 경제성:
  상위 계층의 메모리일 수록 가격이 올라간다.



### 3. 가상 메모리

#### 가상메모리 (Virtual Memory)란?

* 메모리를 관리하는 방법의 하나로, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식을 말한다.
  운영 체제에서 디스크 공간을 메모리 처럼 활용할 수 있는 기능을 제공하고, 디스크 상에 존재하는 이런 파일을 Paging file 이라고 한다.
* 멀티태스킹 운영체제에 흔히 사용 되며, 실제 주기억장치(RAM)보다 큰 메모리 영역을 제공하는 방법으로 사용된다.
* 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽거나 쓸 때에만 물리주소로 바꿔준다.
  * 가상 주소(Virtual address): 프로세스가 참조하는 주소.
  * Physical address: 실제 메모리 주소
* CPU는 가상 메모리를 다루고, 실제 해당 주소 접근 시 MMU 하드웨어 장치를 통해 물리 메모리에 접근한다.
  하드웨어 장치를 사용해야 주소 변환이 빠르기 때문이다.
  * MMU(Memory Management Unit): CPU에서 코드 실행 시, 가상 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치.
    매핑(mapping)을 지원한다.



#### 가상 메모리와 실제 메모리의 관계

* 가상 메모리 안의 프로그램이 실행 될 경우, 실제 메모리에 머물러 있어야한다.
* 전체가 실제 메모리에 있어야하는 것이 아닌, 현재 실행되어야하는 부분만 있으면 되므로, 실제 메모리 용량보다 큰 프로그램이 가상메모리에서 작동한다.



#### 매핑(Mapping)

* 매핑(mapping): 
  * MMU하드웨어에 의해 지원되는 기능.
  * 가상메모리와 실제 메모리 사이의 중계를 맡고 있다.
  * Paging과 Segmentation, 이 두가지 방식을 혼합한 방법. 총 3가지로 분류된다.



#### 페이징(Paging) 기법

* 페이징 기법은 컴퓨터가 메인 메모리에서 사용하기 위해 데이터를 저장하고 검색하는 메모리 관리 기법.

* 페이징 기법으로 컴퓨터의 물리적 메모리는 연속적으로 할당되어 존재할 필요가 없으며,
   연속적으로 존재하지 않는 물리적 메모리라도 페이징 기법을 통해 연속적으로 존재하는 것처럼 이용될 수 있다.

* 가상 메모리 상의 주소 공간을 일정한 크기로 분할.
  주소 공간은 페이지 단위로 나뉘어져 있으며, 실제 기억 공간은 페이지 크기와 같은 프레임으로 나누어 사용함.

  * Frame: 물리 메모리를 일정한 크기로 나눈 블록

  * Page: 가상 메모리를 일정한 크기로 나눈 블록.

    > Frame과 Page는 동일한 크기로 관리 됨.
    > 페이지의 크기는 시스템에 따라 다르다. (일반적으로 4Kbyte)

* 물리메모리(Frame)와 가상메모리(Page)를 대응하기 위해, page mapping 과정이 필요하다.
  이를 위해 페이지 테이블(Page table)을 설정하는 것이 필요하다.

  * 페이지 테이블(page table):
    * 페이징 기법에서 사용되는 자료구조. 프로세스 페이지 정보를 저장하고 있는 테이블.
    * 하나의 프로세스는 하나의 페이지 테이블을 가진다.
    * 색인(페이지 번호)과 
      내용(페이지에 할당된 물리메모리(Frame)의 시작주소. 시작주소와 페이지 주소를 결합해, 물리메모리 주소를 알 수 있다.)
      으로 구성되어있다.

* 장점:

  * 페이징 기법 사용 시, 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화(External fragmentation)를 해결 할 수 있다.
  * 코드를 쉽게 공유할 수 있음.

* 페이지 단위를 작게하면 내부 단편화(Internal fragmentation)를 해결 할 수 있지만, 남는 공간이 적어지기 때문에 
  page mapping 과정이 증가하므로, 서로 trade off 관계에 있다.



### 세그멘테이션(Segmentation)

* 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할하고 메모리를 할당하여 주소를 변환한다.
* 각각의 세그먼트들은 연속적인 공간에 저장되어있다.
* 세그먼트들의 크기가 서로 다르기 때문에, 메모리를 페이징 기법처럼 미리 분할해 둘 수 없다.
* 메모리에 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상메모리 관리 기법.
* mapping을 위해 세그먼트 테이블이 필요하다.