# CHAPTER 03




## 01. 연산자와 피연산자

#### 연산자란?

* 연산을 수행하는 기호
  Ex) '+' 기호의 경우, **덧셈 연산을 수행**하며 **'덧셈 연산자'**로 부름.
* 연산자는 피연산자로 연산을 수행하고 나면, 결과값을 반환.
  


#### 피연산자(operand) 란?

* 연산자가 연산을 수행하기 위한 연산의 대상.

  

#### 예제:


|        X |   +    | 3        |
| -------: | :----: | -------- |
| 피연산자 | 연산자 | 피연산자 |

> **연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현**한 것을 **'식(expression)'**이라고 한다
> 또한, **식을 계산하여 결과를 얻는 것**을 **'식을 평가(evaluation)한다'**라고 한다.



```java
int x = 5;

4 * x + 3
> 4 * 5 + 3
  > 23        // 23의 결과를 얻었지만, 이 값은 쓰이지 않고 사라짐.
```

* 위의 값을 지속하여 사용하고 싶다면, **대입 연산자 기능**을 사용해야함.

  ```java
  int x = 5;
  int y = 4 * x + 3;     //x의 값이 5일 경우, y의 값은 연산 이후 23으로 출력.
  System.out.println(y); //y의 값인 23이 화면에 출력 됨.
  ```

* 만일 평가 결과를 출력하기만 원한다면, println메서드의 괄호() 안에 직접 식을 쓰는것도 가능.

  ```java
  int x = 5;
  System.out.println(4 * x + 3);
  > System.out.println(23);
  ```

  

## 02. 연산자의 종류

| 종류        | 연산자                   | 설명                                         |
| ----------- | ------------------------ | -------------------------------------------- |
| 산술 연산자 | +, -, *, /, %, <<, >>    | 사칙 연산과 나머지 연산(%)                   |
| 비교 연산자 | <, >, <=, >=, ==, !=     | 크고 작음과 같고 다름을 비교                 |
| 논리 연산자 | &&, \|\|, !, &, \|, ^, ~ | '그리고(AND)'와 '또는(OR)'으로 조건을 연결   |
| 대입 연산자 | =                        | 우변의 값을 좌변에 저장                      |
| 기타        | (type) ?: instanceof     | 형변환 연산자, 삼항 연산자, instanceof연산자 |

> 피연산자의 개수로 연산자를 분류하기도 함.
>
> 1. 피연산자의 개수가 1개일 경우: 단항 연산자
> 2. 피연산자의 개수가 2개일 경우: 이항 연산자
> 3. 피연산자의 개수가 3개일 경우: 삼항 연산자
>
> **대부분의 연산자는 '이항 연산자'이다.**



* 둘 다 같은 '-' 기호를 사용하지만, 다른 연산자를 사용하는 식:

|           - | 3    |      -      | 5    |
| ----------: | ---- | :---------: | ---- |
| 부호 연산자 |      | 뺄셈 연산자 |      |



* -3 -5 일 경우
  -3 , 5는 뺄셈 연산자의 피연산자 이고,
  -3의 3은 부호 연산자의 피연산자이다.

  

  * 연산자를 기능별, 피연산자의 개수별로 나누어 분류하는 이유: 
    **연산자의 우선순위 때문에.**


    연산자마다 우선순위가 다르지만, **같은 종류의 연산자들은 우선순위가 비슷.**
    종류별로 우선순위를 외우면 기억하기 수월



## 03. 연산자의 우선순위

* 식에 사용된 연산자가 둘 이상인 경우, 연산자의 **우선순위**에 의해서 연산순서가 결정 됨.
  Ex) 곱셈과 나눗셈(*, /)은 덧셈과 뺄셈(+, -)보다 우선순위가 높음.

  | 식                  | 설명                                                         |
  | ------------------- | ------------------------------------------------------------ |
  | -x + 3              | 단항 연산자가 이항 연산자보다 우선순위가 높다. 그래서 x의 부호를 바꾼 다음 덧셈이 수행 됨.<br />여기서 '-'는 뺄셈 연산자가 아니라 부호 연산자이다. |
  | x + 3 * y           | 곱셈과 나눗셈이 덧셈과 뺄셈보다 우선순위가 높다.<br />그래서 '3 * y'가 먼저 계산 됨. |
  | x + 3 > y - 2       | 비교 연산자(>)보다 산술 연산자 '+'와 '-'가 먼저 수행된다.<br />그래서 'x + 3'과 'y - 2'가 먼저 계산된 다음에 '>'가 수행된다. |
  | x > 3 && x < 5      | 논리 연산자 '&&'보다 비교 연산자가 먼저 수행된다.<br />그래서 'x > 3'와 'x < 5'가 먼저 계산된 다음에 '&&'가. 수행된다.<br />식의 의미는 'x가 3보다 크고 5보다 작다'이다. |
  | result = x + y * 3; | 대입 연산자는 연산자 중에서 제일 우선순위가 낮다.<br />그래서 우변의 최종 연산결과가 변수 result에 저장된다. |

  

## 04. 연산자의 결합 규칙

* 하나의 식에 같은 우선순위의 연산자들이 여러개 있을 경우, 나름대로의 규칙을 가지고 처리를 하는 데,
  그 규칙을 "연산자의 결합규칙"이라고 한다.



* 연산자의 결합 규칙이 왼쪽에서 오른쪽인 경우: 3 + 4 - 5
  
* 연산자의 결합 규칙이 오른쪽에서 왼쪽인 경우: x = y = 3

  > 대입 연산자는 연산자의 결합 규칙이 오른쪽에서 왼쪽으로 진행 된다.
  > 따라서 오른쪽의 대입 연산자인 y = 3 부터 처리 하여, y에 3이 저장되고, 그 이후에 x=3이 수행된다.

  **대입연산자는 우변의 값을 좌변에 저장하고, 저장된 값을 연산결과로 반환한다.**



1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.



* 예제:

  ```java
  class Ex3_1 {
    public static void main(String[] args) {
      int x, y;
      
      x = y = 3; //y에 3이 저장된 후에, x에 3이 저장된다.
      System.out.println("x=" + x);
      System.out.println("y=" + y);
    }
  }
  ```

  > 이 코드의 결과:
  > x = 3
  > y = 3



## 05. 증감 연산자 ++과 --

**증감 연산자 (++) - 피연산자의 값을 1 증가시킨다.**

> 정수와 실수가 모두 **가능**, 상수는 값을 변경할 수 없기에 **불가능**.
> 연산 결과의 타입은 피연산자의 타입과 같다.

**감소 연산자(--) - 피연산자의 값을 1 감소시킨다.**



* 단항 연산자는 피연산자의 왼쪽에 위치하지만. 증가 연산자 '++'와 감소 연산자 '--'는 양쪽 모두 가능.
  이는 두 가지 이름으로 불린다.

  * 전위형(prefix) : 피연산자의 왼쪽에 위치.
* 후위형(postfix) : 피연산자의 오른쪽에 위치.
  
  | 타입   | 설명                          | 사용예   |
  | ------ | ----------------------------- | -------- |
  | 전위형 | 값이 참조되기 전에 증가시킨다 | j = ++i; |
  | 후위형 | 값이 참조된 후에 증가시킨다.  | j = i++; |
  
  #### 그러나, 증감연산자가 수식이나 메서드 호출에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우, 전위형과 후위형의 차이가 없다.





* 예제:

  ```java
  class Ex3_2 {
    public static void main(String args[]) {
      int i=5, j=0;
        
      j = i++;
      System.out.println("j=i++; 실행 후, i=" + i + ", j="+ j);
      
      i=5;      // 결과를 비교하기 위해, i와 j의 값을 다시 5와 0으로 변경.
      j=0;
      
      j = ++i;
      System.out.println("j=++i; 실행 후, i="+ i +",j="+ j);
    }
  }
  ```

  > 이 코드의 결과 값:
  >
  > j=i++; 실행 후, i=6, j=5
  >
  > j=++i; 실행 후, i=6, j=6
  >
  > * 위의 결과가 나오는 이유는, ++i(전위형)는 변수(피연산자)의 값을 먼저 증가 시킨 후 변수의 값을 읽어오고.
  >   후위형은 변수의 값을 먼저 읽어온 후에 값을 증가시키기 때문이다.

  

* 예제 2:

  ```java
  class Ex3_3 {
    public static void main(String args[]) {
      int i=5, j=5;
      System.out.println(i++);
      System.out.println(++j);
      System.out.println("i = " + i ", j = "+j);
    }
  }
  ```

  > 이 코드의 결과 값:
  > 5
  >
  > 6
  >
  > i = 6, j = 6
  >
  > 
  >
  > * 이 코드의 계산 과정

  ```java
  System.out.println(i++);
  System.out.println(++j);
  ```

  ↕️

  ```java
  System.out.println(i);
  i++;
  ++j;
  System.out.println(j);
  ```

  

## 06. 부호 연산자

#### 부호연산자란?

* '-' 이다.
* 피연산자의 부호를 반대로 변경한 결과를 반환한다. (양수➡️음수 , 음수➡️양수 )
* 부호 연산자 중엔, '+'도 있지만, 쓰이는 경우는 거의 없음.
* **boolean형과 char형을 제외한 기본형에만 사용할 수 있다.**

```java
class Ex3_4 {
  public static void main(String[] args) {
    int i = -10;
    i = +i;
    System.out.println(i);
    
    i= -10;
    i = -i;
    System.out.println(i);
  }
}
```

> 이 코드의 결과값:
>
> -10
>
> 10



## 07. 형변환 연산자

#### 형변환이란?

* 변수 또는 상수의 타입을 다른 타입으로 변환하는 것.

* 형변환 방법: 형변환 하고자 하는 변수나 리터럴 앞에 변환하고자 하는 타입을 괄호와 함께 붙여준다.
  Ex) (타입)피연산자

  * 이 때 사용 되는 괄호()는 '캐스트 연산자' 혹은 '형변환 연산자'라고 한다.

  * 형변환을 '캐스팅(casting)'이라고도 한다.

    >  Ex) double d = 85.4;
    >
    > int score = (int)d;
    >
    > 
    >
    > * 단계별 진행 과정
    >
    > Int score = (int)d; ➡️ int score = (int)85.4; ➡️ int score = 85;

* 형변환의 다양한 예시

  | 변환        | 수식      | 결과  |
  | ----------- | --------- | ----- |
  | int ➡️ char  | (char)65  | 'A'   |
  | char ➡️ int  | (int) 'A' | 65    |
  | float ➡️ int | (int)1.6f | 1     |
  | int ➡️ float | (float)10 | 10.0f |

  

* 예제:

  ```java
  class Ex3_5 {
    public static void main(String[] args) {
      double d = 85.4;
      int score = (int)d;
      System.out.println("score="+ score);
      System.out.println("d="+ d);
    }
  }
  ```

  > 이 코드의 결과:
  >
  > Score=85
  >
  > d=85.4 ⬅️ 형변환 후에도 피연산자에는 아무런 변화가 없다.



## 08. 자동 형 변환

* 서로 다른 타입간의 대입이나 연산 시, 형변환으로 타입을 일치시키시는 것이 원칙이지만,
  **편의상의 이유로 형변환을 생략 할 수 있다.** 이 때, **컴파일러**가 생략된 형변환을 **자동적으로 추가**해준다.

* 변환 생략이 가능한 경우


  ```java
  float f = 1234;  // float f = (float)1234;에서 (float)가 생략됨.
  ```

  > 위의 식의 경우, 우변은 int타입의 상수이고, 이 값을 저장하려는 변수의 타입은 실수인 float이다.
  > 서로 타입이 달라서 형변환이 필요하지만, float타입의 변수는 1234라는 값을 저장하는 데 **문제가 없어** 편의상 생략 하였다.

* 변환 생략이 불가능한 경우

  ```java
  byte b = 1000; // 에러. byte타입의 범위 (-128 ~ 127)를 벗어난 값의 대입
  ```

  > 위의 식의 경우, 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려 했기에, 형변환을 생략하면 에러가 발생.
  >
  > * 나타나는 에러메세지: 'incompatible types: possible lossy conversion from int to byte'
  >
  > * 그러나 위 식의 경우, 명시적으로 형변환 할 때, 프로그래머가 의도적으로 한 것으로 간주하고 컴파일러에서 에러가 발생하지않는다.
  >
  >   ```java
  >   byte b = (byte)1000; // Ok. 그러나 값 손실이 발생해서 변수 b에는 -24가 저장됨.
  >   ```


따라서 형변환의 경우,

#### 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환 된다.



| 1byte  | 2byte   | 4byte | 8byte  | 4byte   | 8byte  |
| ------ | ------- | ----- | ------ | ------- | ------ |
| byte ➡️ | short ➡️ | int ➡️ | long ➡️ | float ➡️ | Double |
|        | Chat ↗️  |       |        |         |        |

> 화살표 왼쪽에서 오른쪽으로의 변환은 **자동 형변환이 적용** 되고,
> 오른쪽에서 왼쪽으로의 변환은 **반드시 형변환 연산자를 써야한다.**



## 09. 사칙 연산자

* 피 연산자가 정수형인 경우, 나누는 수로 0을 사용 할 수 없다.

* 예제:

  ```java
  class Ex3_6 {
    public static void main (String args []) {
      int a = 10;
      int b = 4;
      
      System.out.printf("%d + %d = %d%n", a, b, a + b);
      System.out.printf("%d - %d = %d%n", a, b, a - b);
      System.out.printf("%d * %d = %d%n", a, b, a * b);
      System.out.printf("%d / %d = %d%n", a, b, a / b);
      System.out.printf("%d / %f = %f%n", a, (float)b, a / (float)b);
    }
  }
  ```

  > 이 식의 결과:
  > 10 + 4 = 14
  >
  > 10 - 4 = 6
  >
  > 10 * 4 = 40
  >
  > 10 / 4 = 2
  >
  > 10 / 4.000000 = 2.500000

  * 나누기 연산자의 두 피연산자가 모두 int 타입인 경우, 연산결과도 int타입으로 출력된다. (소수점 이하는 모두 버려지게 된다. 반올림 적용 X)

  * 나누기 연산자 시행 시, 정확한 값을 원한다면 두 피연산자 중, 한 쪽이라도 실수형으로 형변환 하여야, 다른 쪽도 자동으로 형변환 되어서 실수의 값을 얻을 수 있다.

    ```java
    // int   float   float   float    float
       10  / 4.0f -> 10.0f /  4.0f /  2.5f
    ```



## 10. 산술 변환

#### 산술 변화란?

* 피연산자 타입의 일치를 위해 자동 형변환 되는것.

* '일반 산술 변환'이라고도 불린다.

* 이항 연산에서만 아니라 단항 연산에서도 일어난다.

* '산술 변환'의 규칙:

  1. 두 피연산자의 타입을 같게 일치시킨다.(보다 큰 타입으로 일치)
     long + int ➡️ long + long ➡️ long
     float + int ➡️ float + float ➡️ float
     double + float ➡️ double + double ➡️ double
  2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
     byte + short ➡️ int + int ➡️ int
     char + short ➡️ int + int ➡️ int
     * 두번째 규칙은 int보다 작은 타입의 표현 범위가 좁아서 연산중에 오버플로우(overflow) 가 발생할 가능성이 높기 때문.

* 예제:

  ```java
  class Ex3_7 {
    public static void main(String[] args) {
      System.out.println(5/2);
      System.out.println(5/(float)2); // (float)5/2의 결과도 동일
    }
  }
  ```

  > 위 식의 결과:
  > 2
  >
  > 2.5



#### 큰 자료형의 값을 작은 자료형에 저장할 경우

* 옳지 않은 예제:

  > byte a = 10;
  >
  > byte b = 20;
  >
  > byte c = a + b; //컴파일 에러가 발생한다. 명시적으로 형변환 필요
  >
  > System.out.println(c);

* 예제 1:

  ```java
  class Ex3_8 {
    public static void main(String[] args) {
      byte a = 10;
      byte b = 30;
      byte c = (byte)(a * b);
      System.out.println(c);
    }
  }
  ```

  > 위 식의 결과:
  > 44
  >
  > * 본래 10*30의 결과는 300 이지만, 형변환(캐스팅,casting)에서 배운 것 처럼, 
  >   **큰 자료형에서 작은 자료형으로 변환하면 데이터의 손실이 발생하므로 값이 바뀔 수 있다.**
  >   300은 byte형의 범위를 넘기 때문에 데이터 손실이 발생하여 44가 변수 c에 저장되는것.



* 예제 2:

  ```java
  class Ex3_9 {
    public static void main(String args[]) {
      int a = 1_000_000;
      int b = 2_000_000;
      
      long c = a * b;
      
      System.out.println(c);
    }
  }
  ```

  > 위 식의 결과:
  > -14544759936
  >
  > * a * b의 결과 값을 담는 변수 c의 자료형이 long타입(8 byte)이기 때문에 결과값 '2000000000000'이 출력 될 것 같지만,
  >   int 타입과 int타입의 연산 결과는 int이기 때문에, 올바른 결과를 얻으려면 변수 a 혹은 b의 타입을 'long'로 형변환 해야한다.

* 예제 3:

  ```java
  class Ex3_10 {
    public static void main(String[] args) {
      long a = 1_000_000 * 1_000_000;
      long b = 1_000_000 * 1_000_000L;
      
      System.out.println("a=" +a);
      System.out.println("b=" +b);
    }
  }
  ```

  > 위 식의 결과:
  > a= -727379968
  >
  > b= 1000000000000





## 11. Math.round()로 반올림 하기

* 반올림을 하고싶다면, Math.round()를 사용하면 된다.
  소수점 첫째 자리에서 반올림 한 결과를 정수로 반환 함.

* 소수점 첫째 자리가 아닌 다른 자리에서 반올림을 하려면. 10의 n제곱으로 적절히 계산해야함.

* 예제:

  ```java
  class Ex3_11 {
    public static void main(String[] args){
      double pi = 3.141592;
      double shortPi = Math.round(pi * 1000) / 1000.0;
      System.out.println(shortPi);
    }
  }
  ```

  > 위 식의 결과:
  >
  > 3.142
  >
  > * 결과의 이유:
  >   round메서드는 매개변수로 받은 값을 소수점 첫째 자리에서 반올림 하기 때문에,
  >   Math.round(3141.592)의 결과는 3142 인 것.
  > * 만일 위의 과정에서 1000.0이 아니라 1000으로 나누었다면, 결과는 3.142가 아닌, 3이 되었을 것.
  >   같은 int와 int의 나눗셈 결과가 되어버리기 때문.



## 12. 나머지 연산자

#### 나머지 연산자란?

* 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지의 값을 결과로 반환 한다.
* 나눗셈에서처럼 나누는 수(오른쪽 피연산자)로 0을 사용할 수 없다.
* 피연산자로 정수만 허용.
* 주로 짝수, 홀수 또는 배수 검사 등에 주로 사용 됨.



---



* 예제1:

```java
class Ex3_12 {
  public static void main(String[] args) {
    int x = 10;
    int y = 8;
    
    System.out.printf("%d을 %d로 나누면, %n", x, y);
    System.out.printf("몫은 %d이고, 나머지는 %d입니다.%n", x/ y, x % y);
  }
}
```

> 위 식의 값:
>
> 10을 8로 나누면,
>
> 몫은 1이고, 나머지는 2 입니다.
>
> * 나눗셈 연산자와 나머지 연산자를 이용해서 몫과 나머지를 구하는 예제.



* 예제2:

  ```java
  class Ex3_13 {
    public static void main(String[] args) {
      System.out.println(-10%8);
      System.out.println(10%-8);
      System.out.println(-10%-8);
    }
  }
  ```

  > 위 식의 값:
  >
  > -2
  >
  > 2
  >
  > -2
  >
  > * 나머지 연산자(%)는 나누는 수로 음수도 허용. 그러나, 부호는 무시됨.
  >
  > * 위와 같은 이유로, 결과는 절대값으로 나눈 나머지와 결과가 같음.
  >
  >   ```java
  >   System.out.println(10 % 8);  //10을 8로 나눈 나머지 2가 출력된다.
  >   System.out.println(10 % -8); //위와 같은 결과를 얻는다.
  >   ```
  >
  >   * 피연산자의 부호를 모두 무시하고, 나머지 연산을 한 결과에 왼쪽 피연산자의 부호를 붙이면 됨.



## 13. 비교 연산자

#### 비교 연산자란?

* 두 피연산자를 비교하는 데 사용되는 연산자.

  * 주로 조건문과 반복문의 조건식에 사용 됨. 연산결과는 true와 false 둘 중의 하나이다.
  * 이항 연산자이므로 비교하는 **피연산자의 타입이 서로 다를 경우, 자료형의 범위가 큰 쪽으로 자동 형변화** 하여 피연산자의 타입을 일치 시킨 후 비교 함.

* 대소비교 연산자 <, >, <=, >=

  * 두 피연산자의 값의 크기를 비교하는 연산자.

  * 참이면 true, 거짓이면 false를 결과로 반환.

  * 기본형 중, booleam을 제외한 나머지 자료형에 사용 가능. 참조형에는 사용 불가능

    * 
      | 비교 연산자 | 연산결과                                   |
      | ----------- | ------------------------------------------ |
      | >           | 좌변 값이 크면, true 아니면 false          |
      | <           | 좌변 값이 작으면, true 아니면 false        |
      | >=          | 좌변 값이 크거나 같으면, true 아니면 false |
      | <=          | 좌변 값이 작거나 같으면, true 아니면 false |

* 등가비교 연산자 == !=

  + 두 피연산자의 값이 같은지 또는 다른지를 비교하는 연산자.

  + 대소비교 연산자(<, >, <=, >=)와는 달리, 모든 자료형(기본형,참조형)에 사용 가능.

  + 기본형의 경우, 변수에 저장되어 있는 값이 같은지 알 수 있음.
    참조형의 경우 객체의 주소값을 저장하기 때문에 두개의 피연산자(참조변수)가 같은 객체를 가리키고 있는지 (주소값이 같은지)를 알 수 있음.

  + 기본형과 참조형은 서로 형변환이 가능하지 않기 때문에, **기본형과 참조형을 비교하는 것은 불가능.**

    | 비교 연산자 | 연산결과                          |
    | ----------- | --------------------------------- |
    | ==          | 두 값이 같으면, true 아니면 false |
    | !=          | 두 값이 다르면. true 아니면 false |

    * 비교 연산자는 수학기호와 유사한 기호와 의미를 가지고 있으나,
      '두 값이 같다'는 의미로 '='가 아닌, '=='를 사용하는 것을 기억하자.
    * '='는 '대입 연산자'이기 때문에 '=='로 표현 하는 것.



## 14. 문자열의 비교

* 두 문자열을 비교할 때엔, 비교 연산자 '==' 대신 equals()라는 메서드를 사용해야 함.

* 비교 연산자는 두 문자열이 완전히 같은 것인지 비교할 뿐, 문자열의 내용이 같은지 비교하기 위해서는 equals()를 사용하는 것.

* equals()는 비교하는 두 문자열이 같으면 trus, 다르면 false를 반환 한다.

  ```java
  String str = new String("abc");
  
  // equals()는 두 문자열의 내용이 같으면 true, 다르면 false를 결과로 반환
  boolean result = str.equals ("abc"); //내용이 같으므로 result에 true가 저장됨.
  ```

  > 원래 String은 클래스 이므로, new를 사용해서 객체를 생성해야한다.
  >
  > ```java
  > String str = new String("abc"); //String클래스의 객체를 생성
  > String str = "abc";             //위의 문장을 간단히 표현
  > ```
  >
  > 그러나, 특별히 String만 new를 사용하지 않고, 위와 같이 간단히 쓰는 것이 허용 됨.

* 예제:

  ```java
  class Ex3_14 {
    public static void main(String[] args) {
      String str1 = "abc";
      String str2 = new String("abc");
      
      System.out.printf("\"abc\"==\"abc\" ? %b%n", "abc"=="abc");
      System.out.printf(" str1==\"abc\" ? %b%n",    str1=="abc");
      System.out.printf(" str2==\"abc\" ? %b%n",    str2=="abc");
      System.out.printf("str1.equals(\"abc\") ? %b%n", str1.equals("abc"));
      System.out.printf("str2.equals(\"abc\") ? %b%n", str2.equals("abc"));
      System.out.printf("str2.equalsIgnoreCase(\"ABC\") ? %b%n", str2.equalsIgnoreCase("ABC"));
    }
  }
  ```

  > 위 식의 값:
  >
  > "abc"=="abc" ? true
  >
  > str1=="abc" ? true
  >
  > str2=="abc" ? false
  >
  > str1.equals("abc") ? true
  >
  > str2.equals("abc") ? true
  >
  > str2.equals("ABC") ? false
  >
  > str2.equalsIgnoreCase("ABC") ? true
  >
  > * str2와 "abc"의 내용이 같은데도 '=='로 비교하면, false를 결과로 얻는다. 내용이 같지만 객체가 다르기 때문.
  > * 그러나 equals()는 객체가 달라도 내용이 같으면 true를 반환. 때문에 문자열을 비교할 때는 항상 equals()를 사용해야한다.
  > * 만일 대소문자를 구별하지 않고 비교하고 싶다면, equals() 대신, equalsIgnoreCase()를 사용.



## 15. 논리 연산자 && || !

* 'x가 4보다 작거나 또는 10보다 크다.' 와 같이 두 개의 조건이 결합된 경우 사용 하는 연산자.

* 논리 연산자는 둘 이상의 조건을 '그리고(AND)'나 '또는(OR)'으로 연결하여 하나의 식으로 표현.

  > 논리 연산자 '&&': 그리고(AND) - 두 피연산자가 모두 true 일 때만 true를 결과로 얻음.
  > 논리 연산자 '||' : 또는(OR) - 두 피연산자 중 어느 한 쪽만 true이어도 true를 결과로 얻음.

* **논리 연산자는 피연산자로 boolean형 또는 boolean형 값을 결과로 하는 조건식만을 허용**


* 논리 연산자의 피연산자가 '참(true)인 경우'와 '거짓(false)인 경우':

  | x     | y     | x \|\| y | x && y |
  | ----- | ----- | -------- | ------ |
  | true  | true  | true     | true   |
  | true  | false | true     | flase  |
  | false | true  | true     | false  |
  | false | false | false    | False  |

   

* 논리 연산자의 예제:

  1. **x는 10보다 크고, 20보다 작다.**

     * 'x > 10'와 'x < 20'가 '그리고(and)'로 연결된 조건이므로 가능한 식

       > x > 10 && x < 20  
       > 10 < x && x < 20  // 보통 변수를  왼쪽에 쓰지만, 가독성측면에서 좋게 하기 위해, 'x > 10'는 ' 10 < x'로도 표현 할 수 있기 때문에, 이와 같이 표현 함.
       >
       > 
       >
       > * 하지만, 논리연산자를 생략하고 '10 < x < 20'과 같이 표현하는것은 허용되지 않음.

  2. **i는 2의 배수 또는 3의 배수이다.**

     * 어떤 수가 2의 배수라는 얘기는, 2로 나누었을 때 결과가 0이라는 의미 이기 때문에,
       나머지 연산의 결과가 0인지 확인 하면 된다.

     * '또는'으로 두 조건이 연결되었으므로, 논리연산자 '||(OR)'를 사용 하면 된다.

       > i%2==0 || i%3==0
       >
       > // i의 값이 8일 경우 위 예시는 아래와 같이 계산.
       >
       > 
       > i%2==0 || i%3==0
       >
       > -> 8%2==0 || 8%3==0
       > ->       0==0 || 2 == 0
       > ->        true || false
       > ->               true

  3. **i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다.**

     * 이전 조건에 6의 배수를 제외하는 조건이 붙은 경우.

     * 6의 배수가 아니어야 한다는 조건은, 'i%6!=0'이고, 조건은 '&&(AND)' 을 사용.

       > (i%2==0 || i%3==0) & i%6!=0
       > // 위의 식에 괄호를 사용 한 이유: **'&&'가 '||'보다 우선 순위가 높기 때문**
       >  위의 이유 때문에, '&&'와 '||'가 한 식에 모두 포함 되어있는 경우, 괄호를 사용해 우선순위를 명확하게 해주는 것이 좋다.

  4. **문자 ch는 숫자('0'~'9')이다.**

     * 입력된 문자가 숫자('0'~'9')인지 확인하는 식은 다음과 같다.

       > '0' <= ch && ch <= '9'
       >
       > * 유니코드에서 문자 '0'부터 '9'까지 연속적으로 배치되어있기 때문에 가능한 식.
       >
       >   > ​    문자   : '0'  /  '1'  /  '2' /  '3' /  '4' /  '5' /  '6' /  '7' /  '8' /  '9' 
       >   > 문자코드: 48  /  49 /  50 / 51 / 52 / 53 /  54 / 55 /  56 /  57 
       >
       > * 값이 ch의 값이 '5'인 경우, 다음과 같은 과정으로 연산.
       >
       > '0' <= ch && ch <= '9'
       >
       > -> '0' <= 5 && 5 <= '9'
       >
       > -> '48' <= 53 && 53 <= 57
       >
       > ->         true  &&.    true
       >
       > ->                 true

  5. **문자 ch는 대문자 또는 소문자이다.**

     * 4의 경우와 마찬가지로 문자 'a' 부터 'z' 까지,
       그리고 'A'부터 'Z'까지도 연속적으로 배치되어 있으므로, 식은 다음과 같다.

       > ('a' <= ch && ch <= 'z') || ('A' <= ch & ch <= 'Z')

     * 예제:

       ```java
       import java.util.Scanner; // Scanner 클래스를 사용하기 위해 추가
       
       class Ex3_15 {
         public static void main(String[] args) {
           Scanner scanner = new Scanner(System.in);
           char ch = ' ';
           
           System.out.printf("문자를 하나 입력하세요.>");
           
           String input = scanner.nextLine();
           ch = input.charAt(0);
           
           if('0' <= ch && ch <= '9') {
             System.out.printf("입력하신 문자는 숫자입니다.%n");
           }
           
           if(('a' <= ch && ch <= 'z') || ('A'<= ch && ch <= 'Z')) {
             System.out.printf("입력하신 문자는 영문자입니다.%n");
           }
         } // main
       }
       ```

       > 위 식의 결과1:
       > 문자를 하나 입력하세요.> 7
       > 입력하신 문자는 숫자입니다.

       

       > 위 식의 결과2:
       > 문자를 하나 입력하세요.> a
       >
       > 입력하신 문자는 영문자입니다.

     * 위 예제의 조건문 if는 괄호() 안의 연산결과가 참인 경우 블럭{} 내의 문장을 수행.
       때문에 아래의 코드는, '0'<=ch && ch <='9'가 참일때, 화면에 '입력하신 문자는 숫자입니다.'라고 출력함.

       > If('0' <= ch && ch <= '9') {
       >
       > ​    System.out.printf("입력하신 문자는 숫자입니다.%n");
       >
       > }





## 16. 논리 부정 연산자

* 이 연산자는 피연산자가 true면 false를, false면 true를 결과로 반환.(true와 false를 반대로 바꿈.)

  | x     | !x    |
  | ----- | ----- |
  | true  | false |
  | false | true  |

* 논리 부정 연산자 '!'가 주로 사용 되는 곳은, 조건문과 반복문의 조건식.
  이 연산자를 잘 사용하면, 조건식이 보다 이해하기 쉬워진다.
  Ex) 문자 ch는 소문자가 아니다.
         논리 연산자                             논리 부정 연산자

  ch < 'a' || ch > 'z'.     ↔️      !('a <=ch && ch <= 'z' )

* 예제:

  ```java
  class Ex3_16 {
    public static void main(String[] args) {
      boolean b = true;
      char ch = 'C';
      
      System.out.printf("b=%b%n", b);
      System.out.printf("!b=%b%n", !b);
      System.out.printf("!!b=%b%n", !!b);
      System.out.printf("!!!b=%b%n", !!!b);
      System.out.println();
      
      System.out.printf("ch=%c%n", ch);
      System.out.printf("ch < 'a' || ch > 'z'=%b%n", ch < 'a' || ch > 'z');
      System.out.printf("!('a'<=ch && ch<='z')=%b%n", !('a'<=ch && ch<='z'));
      System.out.printf("  'a'<=ch && ch<='z' =%b%n", 'a'<=ch && ch<='z');
    }//main의 끝
  }
  ```

  > 위 식의 결과:
  >
  > b=true
  >
  > !b=false
  >
  > !!b=true
  >
  > !!!b=false
  >
  > 
  >
  > ch=C
  > ch < 'a' || ch>'z'= true
  >
  > !('a'<=ch && ch<='z')= true
  >
  > 'a'<=ch && ch<='z'= false

* '!!b'의 경우, !가 피연산자와 가까운 것 부터 먼저 연산된다.





## 17. 조건 연산자

#### 조건 연산자란?

* 조건식, 식1,식2 모두 세 개의 피연산자를 필요로하는 **삼항 연산자**
* 삼항 연산자는 조건 연산자 하나 뿐이다.

---

* 조건 연산자는 첫 번째 피연산자인 조건식의 **평과 결과에 따라 다른 결과를 반환**한다.
  조건식의 평가 결과가 true라면 식 1이, false라면 식 2가 연산 결과가 된다.

* 가독성을 높이기 위해 조건식을 괄호()로 둘러싸는 경우가 많지만 **필수는 아니다.**

  > ex) result = (x > y) ? x : y ; *// 괄호 생략 가능*
  > x>y가 true라면 변수 result에는 x의 값이 저장, false라면 y의 값이 저장된다.
  >
  > * x의 값이 5, y의 값이 3일경우.
  >   result = (x > y) ? x : y;
  >   -> result = (5>3)? 5 : 3;
  >   -> result = (true)? 5 : 3;
  >   -> result = 5;

* 조건 연산자는 조건문인 if문으로 바꿔 쓸 수 있음.
  **if문 대신 조건 연산자를 사용하면 코드를 보다 간단히 할 수 있다.**

  > ​                                               if (x > y)
  > Result = (x>y) > x:y;   ↔️        result = x; *// x> y가 true 일 때*
  >
  > ​                                                  else
  >
  > ​                                                   result = y; *// x>y가 false 일 때

* 조건 연산자의 식 1과 식 2의 타입이 다른 경우, 이항연산자 처럼 산술변환이 발생한다.

  > x = x + (mod < 0.5 ? 0:0.5)     // 0과 0.5의 타입이 다르다.
  > -> x=x+(mod <0.5? 0.0 : 0.5)  // 0이 0.0으로 자동 형변환 되었다.
  >
  > * 자동 형변환이 일어나서 double타입으로 통일 되고, 연산 결과 역시 double타입이 된다.

* 예제: 조건 연산자를 이용하여 변수의 절대값을 구한 후, 부호를 붙여 출력한다.

  ```java
  class Ex3_17 {
    public static void main(String[] args) {
      int x,y,x;
      int absX, absY, absZ;
      char signX, signY, signZ;
      
      x= 10;
      y= -5;
      z= 0;
      
      absX= x >= 0 ? x : -x;  //x의 값이 음수이면, 양수로 만든다.
      absY= y >= 0 ? y : -y;
      absZ= z >= 0 ? z : -z;
      signX= x > 0 ? '+' : ( x==0 ? ' ' : '-'); // 조건 연산자를 중첩
      signY= y > 0 ? '+' : ( y==0 ? ' ' : '-');
      signZ= z > 0 ? '+' : ( z==0 ? ' ' : '-');
      
      System.out.printf("x=%c%d%n", signX, absX);
      System.out.printf("y=%c%d%n", signY, absY);
      System.out.printf("z=%c%d%n", signZ, absZ);
    }
  }
  ```

  > 위 식의 결과:
  > x=+10
  > y=-5
  >
  > z=0



## 18. 대입 연산자

* 대입 연산자는 변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는 데 사용.

* 오른쪽 피연산자의 값(식이라면 평가값)을 왼쪽 피연산자에 저장한다.
  저장된 값을 연산결과로 반환.

  > System.out.println(x=3); //변수 x에 3이 저장됨
  > System.out.println(3);     //연산결과인 3이 출력됨.

* 대입 연산자는 연산자들 중에서 가장 낮은 우선순위를 가지고 있다.
  따라서 식에서 제일 나중에 수행 됨.



#### Ivalue와 rcalue

* 대입 연산자의 왼쪽 피연산자를 'lvalue(left value)', 오른쪽 피연산자를 'rvalue(right value)'라고 한다.
* 대입 연산자의 rvalue는 변수 뿐만 아니라, 식 , 상수 등이 모두 가능.
  lvalue는 반드시 변수처럼 값을 변경할 수 있어야 함.
  때문에 **리터럴이나 상수같이 값을 저장 할 수 없는 것들은 lvalue가 될 수 없다.**

```java
int i = 0;
3 = i + 3;         //에러.lvalue가 값을 저장할 수 있는 공간이 아니다.
i + 3 = i;         //에러.lvalie의 연산결과가 리터럴(i+3 > 0+3 > 3) 

final int MAX = 3; //변수 앞에 키워드 final을 붙이면 상수가 된다.
MAX = 10;          //에러. 상수(MAX)에 새로운 값을 저장할 수 없다.
```



## 19. 복합 대입 연산자

* 대입 연산자는 다른 연산자(op)와 결합하여 'op='와 같은 방식으로 사용 될 수 있다.
* 예로, 'i = i +3'은 'i += 3' 과 같이 표현 될 수 있다.
* 결합된 두 연산자는 반드시 공백없이 붙여 써야 한다.
  
* 복합 연산자의 사용 예:

| op=          | =                 |
| ------------ | ----------------- |
| i +=3;       | i = i + 3;        |
| i -= 3;      | i = i - 3;        |
| i *= 3;      | i = i * 3;        |
| i /= 3;      | i = i / 3;        |
| i %= 3;      | i = i % 3;        |
| i <<= 3;     | i = i << 3;       |
| i >>= 3;     | i = i >> 3;       |
| i &= 3;      | i = i & 3;        |
| i ^= 3;      | i = i ^ 3;        |
| i \|= 3;     | i = i \| 3;       |
| i *= 10 + j; | i = i * (10 + j); |

* 오른쪽 표의 내용은 왼쪽과 동일 한 의미의 식이다.
* 위 표의 마지막 줄 처럼, **대입 연산자의 우변이 둘 이상의 항으로 이어져 있는 경우**,
  'i*=10+j'를 'i = i * 10 + j'와 같은 경우로 오해하지 않도록 주의.





---

QnA1) System.out.printf("\"abc\ "==\ "abc\ " ? %b%n", "abc"=="abc");
위의 식에서 있는  \ 의 의미는 무엇인가요? 

> escape문 (java) - 링크 참조 하여 주심 "abc" 를 표현하고 싶었을 때, "" 안의 내용만 문장으로 생각을 하기 때문에 "" "" 는 쓸 수 없기 때문에 \를 쓰는 것.

QnA2) 'a'>ch || ch>'z'
의 의미를 살짝 이해하기가 힘든 것 같습니다.  값이 false이기 때문에 이 식의 의미가  '문자 ch는 소문자가 아니다' 라는 조건이 되는건지..?

a미만 z초과...라서..? ㅋㅋ...